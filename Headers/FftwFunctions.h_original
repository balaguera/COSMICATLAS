/**
 *  @file FftwFunctions.h
 *
 *  @brief The class FftwFunctions
 *
 *  This file defines the interface of the class FftwFunctions, used to
 *  measure the 3D power spectrum 
 */


//#define HEALPIX
#undef HEALPIX


#ifndef __FFTW_FUNCTIONS__
#define __FFTW_FUNCTIONS__

#define ic_rank 3

# include <ctime>
# include <cmath>
# include <cctype>
# include <string>
# include <iostream>
# include <math.h>
# include <stdio.h>
# include <fstream>
# include <cassert>
# include <vector>
# include <algorithm>


# include <alm.h>
# include <alm_fitsio.h>
# include <healpix_map.h>
# include <healpix_map_fitsio.h>
# include <healpix_data_io.h>
# include <healpix_base.h>
# include <healpix_base2.h>
# include <healpix_data_io.h>
# include <alm_powspec_tools.h>
# include <alm_healpix_tools.h>
# include <cxxutils.h>


# include "fftw_array.h" 
# include "NumericalMethods.h"
# include "CoordinateSystem.h" 
# include "ScreenOutput.h" 
# include <omp.h>
# include <complex>



using namespace std;


// *****************************************************************************************************
/*!\class FftwFunctions
  
 * @details   Manipulation of function in Fourier space
 * @author    Andres Balaguera Antolinez 
 * @author    Federico Marulli & Jennifer Pollack
 * @author    Optimization and parallelization by Luca Tornatore
 * @version   1.1a
 * @date      2013-2015, ROMA3
 
 * @brief CLASS FftwFunctions

 *NOTES RELATED TO FFTW 
 *The outputs of the FFTW has dimensions N1*N2*(N3/2+1), 
 *where only half of frequencies in the third component (kz)                                               
 *are stored. The other half of the third component can be found using Hermitian Symmetry (see below).                                                   
 * The original output of the FFTW has the ordering                                                     
 *                                                                                                   
 *    index:    o_i      =  0    1     2     3    ...   N/2     N/2+1       N/2+2     ...   N-1                           
 *    freq:     k_i      =  0   k_f   2k_f  3k_f  ...   k_N   -k_n+k_f   -k_n+2k_f   ...   -k_f                      
 *    freq:    q_i/k_f   =  0    1     2     3    ...   N/2    -N/2+1      -N/2+2     ...   -1        in units of k_f                                                                                       *                           
 *where k_f is the fundamental mode, N is the number of grid cells per dimension in the DFT and
 *
 *    k_n= (N/2)k_f 
 *
 *is the Nyquist frequency. Hence, the slot for the frequency -k_n is not written in the output. We need to explicitely use the negative and positive values                                           
 *to account for all posible configurations properly, 
 *specialy when computing the Bispectrum. For the Power spectrum it is not necessary
 *for we do not expect to exploit information at the scales of the Nyquist freq.                                                  
 *
 *We therfore expand the loops over the wavenumbers by introducing one more                                                     
 *slot, such that the new ordering (i) and coordinates (q_i/k_f) read as                                 
 *
 *   index:    i       =   0   1     2      j  ...  N/2,  N/2+1    N/2+2     N/2+3    ...        j            N-2     N-1    N
 *   freq:     k_i     =   0   k_f  2k_f  jk_f ...  k_N,  -k_N   -k_n+k_f  -k_n+2k_f  ...   -k_n+(j-1)k_f   -3k_f    -2k_f  -k_f                          
 *   freq:     q_i/k_f =   0   1     2      j  ...  N/2   -N/2   -N/2+1     -N/2+2    ...     -N/2+(j-1)      -3      -2     -1    in units of k_f                                                          *                                                        
 *
 * Hence, the new coordinates of the modes are              
 *                                              
 *    q_i/k_f  = i      for i<=N/2, 
 *
 * and  
 *
 *    q_i/k_f  =  i-(N+1)    for i>=N/2+1                                                      
 *
 * Similarly, to map the new index to the original output, we have                                      
 *
 *    o_i  = i       for i<=N/2, 
 *
 * and
 *   
 *    o_i = i-1    for i>=N/2+1, 
 *
 *such that for i=N/2, o_i=i and for i= N/2+1, o_i is also o_i=i.                                                                                          
 *
 *For the third (kz) component of the DFT we only have N3/2+1 elements displayed originally as                               
 *                                                                                                    
 *    index     o_k       =  0   1   2   3   i ...  N3/2                                                                     
 *    freq     q_k/f_f    =  0   1   2   3   i ...  N3/2                                                                      
 *                                                                                                     
 * We reorder the components as we did above for the x-y components. However, in this case, the amplitude         
 * at a coordinate -k_i is obtained by Hermitian symmetry                                               
 *                                                                                                     
 *       delta(kx,ky,-kz)=delta(-kx,-ky,kz)*.                                                         
 *                                
 *That is, when we use the complex conjugate to obtain the negative z-plane, we need to reverse the sign of the kx and ky components.
 *Then, the reordered index is                                                                         
 *
 *      i3        =  0   1  2   j ...  N3/2   N3/2+1   N3/2+2    N3/2+3  ...     j      ... N3-2  N3-1   N3   
 *   q_i3/k_f     =  0   1  2   j ...  N3/2    N3/2    N3/2-1    N3/2-2  ...  N3-(j-1) ...    3    2     1   
 *
 *that is,  
 *
 *  q_i3/k_f = i     for i<=N/2, 
 *
 *and 
 *
 *  q_i3/k_f = N3-(i-1)   for i>=N/2+1. 
 *
 *The index need in the function ijk() is fabs( q_i / k_f ).                                          
*/



// *****************************************************************************************************

class CosmologicalFunctions;

class Parameters;



/**
 *  @class Parameters FftwFunctions.h "Lib/Headers/FftwFunctions.h"
 *
 *  @brief The class FFtwFunctions
 *
 *  This class is used to measure 3D power spectrum
 */


class FftwFunctions{
  
 private:

  //////////////////////////////////////////////////////////
  /**
   *  @brief Obejct of type GalaxyOperations 
   */
  CoordinateSystem Go;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Obejct of type ScreenOutput 
   */
  ScreenOutput So;
  
  //////////////////////////////////////////////////////////
  /**
   *  @brief Minimum X-coordinate of the sample
   */
  double Xmin; 

  //////////////////////////////////////////////////////////
  /** 
   *  @brief Maximim X-coordinate of the sample
   */
  double Xmax; 
 
  ////////////////////////////////////////////////////////// 
  /** 
   *  @brief Minimum Y-coordinate of the sample
  */
  double Ymin; 

  ////////////////////////////////////////////////////////// 
  /** 
   *  @brief Maximum Y-coordinate of the sample
  */
  double Ymax; 


  //////////////////////////////////////////////////////////
  /** 
   *  @brief Minimum Z-coordinate of the sample
   */
  double Zmin; 

  //////////////////////////////////////////////////////////
  /** 
   *  @brief Maximum Z-coordinate of the sample
   */
  double Zmax; 
  //////////////////////////////////////////////////////////

  /** 
   * @brief Vector used in FFTW routines
   */
  int *n=(int *)malloc(ic_rank*sizeof(float));

  //////////////////////////////////////////////////////////
  /** 
   * @brief Vector used in FFTW routines for the Bispectrum
   */
  int *n2=(int *)fftw_malloc(ic_rank*sizeof(float));


  //////////////////////////////////////////////////////////
  /** 
   * @brief Offset in X direction
   */
  double Xoffset;   

//////////////////////////////////////////////////////////
  /** 
   * @brief Offset in Y direction
   */
  double Yoffset;   

//////////////////////////////////////////////////////////
  /** 
   * @brief Offset in Z direction
   */
  double Zoffset;   

  
//////////////////////////////////////////////////////////
  /** 
   * @brief get the value of private member Number of  FftwFunctions::n_gal  
   * @return FftwFunctions::n_gal  
  */
  double _n_gal(){return n_gal; }





  //////////////////////////////////////////////////////////
  /** 
   * @brief Number of random objects
   */
  int n_ran;   
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief get the value of private member Number of FftwFunctions::n_ran  
   * @return FftwFunctions::n_ran
   */
  double _n_ran(){return n_ran; }

//////////////////////////////////////////////////////////
  /** 
   * @brief Weighted number of galaxies
   */
  double w_g;  
  
//////////////////////////////////////////////////////////
  /** 
   * @brief get the value of private member Number of FftwFunctions::w_g
   * @return FftwFunctions::w_g
   */
  double _w_g(){return w_g; }
  
//////////////////////////////////////////////////////////
  /** 
   * @brief Weighted number of random objects
   */
  double w_r;   

//////////////////////////////////////////////////////////
  /** 
   * @brief get the value of private member Number of FftwFunctions::w_r
   * @return FftwFunctions::w_r
   */
  double _w_r(){return w_r; }

//////////////////////////////////////////////////////////
  /** 
   * @brief Parameter alpha, the ratio between the weighted number of galaxies and the weighted number of randoms 
   */
  double alpha;

  //////////////////////////////////////////////////////////
    /** 
   * @brief get the value of private member Number of FftwFunctions::alpha
   * @return FftwFunctions::alpha
   */
  /** Return alpha*/
  double _alpha(){return alpha; }

  //////////////////////////////////////////////////////////
  /** 
   * @brief Parameter used to compute shot nnoise in power spectrum
   */
  double s_g;  

  //////////////////////////////////////////////////////////
  /** 
   * @brief Parameter used to compute shot nnoise in power spectrum
   */
  double s_r;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Parameter used to compute shot noise in bispectrum
   */
  double sr1;  

  //////////////////////////////////////////////////////////
  /** 
      @brief Parameter used to compute shot noise in bispectrum
  */
  double sr2;

//////////////////////////////////////////////////////////
  /** 
      @brief Parameter used to compute shot noise in bispectrum
  */
  double sg1;  

//////////////////////////////////////////////////////////
  /** 
      @brief Parameter used to compute shot noise in bispectrum
  */
  double sg2;


  
  //////////////////////////////////////////////////////////
  /** 
   * @brief get the value of private member Number of FftwFunctions::normal_power
   * @return FftwFunctions::normal_power
   */
  double _normal_power(){return normal_power; }
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Used in the normalization in bispectrum 
   */
  double normal_p;
  
//////////////////////////////////////////////////////////
  /** 
   *    @brief  Normalization of window function 
   */
  double normal_window;
  
//////////////////////////////////////////////////////////
  /** 
   *    @brief  Return normalization of window function 
   */
  double _normal_window(){return normal_window; };
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief  Used in the normalization in bispectrum 
   */
  double normal_b;
  
//////////////////////////////////////////////////////////
  /** 
   *   @brief  Normalization in bispectrum 
   */
  double normal_bispectrum;
  
//////////////////////////////////////////////////////////
  /** 
   *  @brief  Normalization in power spectrum 
   */
  double normal;
  

//////////////////////////////////////////////////////////
  /** 
   * @brief Return Poisson Shot noise 
   */
  double _shot_noise(){return shot_noise; }
  
//////////////////////////////////////////////////////////
  /** 
   * @brief  Poisson Shot noise for window function
   */
  double shot_noise_window;

//////////////////////////////////////////////////////////
  /** 
   * @brief Poisson Shot noise for bispectrum 
   */
  double shot_noise_b1;

//////////////////////////////////////////////////////////
  /** 
   * @brief Poisson Shot noise for bispectrum
   */
  double shot_noise_b2;
  
//////////////////////////////////////////////////////////
  /** 
   * @brief Correct for mass assignment scheme 
   */
  bool MAS_correction;

//////////////////////////////////////////////////////////  
  /** used to avoid if blocks in correction_MAS */
  double correction_MAS_exp;
  
//////////////////////////////////////////////////////////
  /**
  * \brief pointer to different Mass assignmetn scheme. \details Three different MAS     
  * are available for interpolation of the density  
  * field. Insted of having if blocks inside a massively called function, we preset
  * three different functions; this pointer shall point to the correct one at runtime.
  */
  double (FftwFunctions::*MAS_ptr)(double);
  
//////////////////////////////////////////////////////////
  /** 
   * @brief Mass assignment scheme 
   */
  string MASS;

//////////////////////////////////////////////////////////
  /**
  * \brief NGP Mass assignment scheme.
  */
  double MAS_NGP(double);
  
//////////////////////////////////////////////////////////
  /**
  * \brief CIC Mass assignment scheme.
  */
  double MAS_CIC(double);

//////////////////////////////////////////////////////////
  /**
  * \brief TSC Mass assignment scheme.
  */
  double MAS_TSC(double);  
//////////////////////////////////////////////////////////
  /**
   * @brief Statistics measured in this class. Can be Pk_fkp, Pk_ys, Pk_yb, Pk_y_ds 
   */
  string statistics;
  
//////////////////////////////////////////////////////////
  /**
   * @brief  Number of grid cells in each direction for the DFT 
   */  
  int Nft;

//////////////////////////////////////////////////////////
  /**
   * @brief  Number of grid cells in each direction for Bispectrum fast 
   */  
  int sgrid;


//////////////////////////////////////////////////////////
  /**
   * @brief  Total number of grid cells used in arrays defined for the Bispectrum fast
   */  
  int new_sgrid;


//////////////////////////////////////////////////////////
  /**
   * @brief  inverse of the number of grid cells in each direction for the DFT 
   */  
  double rNft;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue 
   */
  vector <double> cell_x;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue 
   */
  vector <double> cell_y;


  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue 
   */
  vector <double> cell_z;


  

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_xx;

//////////////////////////////////////////////////////////
  /** 
   * @brief Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_yy;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_zz;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_xy;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_xz;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_g_yz;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xxx; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_yyy; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_zzz; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xxy; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xxz; 

//////////////////////////////////////////////////////////
    /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_yyx; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_yyz;   

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_zzx; 

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_zzy;

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xyy;

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xzz;   

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_yzz; 

//////////////////////////////////////////////////////////
    /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_xyz;

//////////////////////////////////////////////////////////
    /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_yxz;

//////////////////////////////////////////////////////////
   /** 
   * @brief  Vectors for the galaxy catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_g_zxy;   

//////////////////////////////////////////////////////////
    /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r;
  
//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_xx;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_yy;
  
//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_zz;
  
//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_xy;
  
//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_xz;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector <double> data_r_yz;

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xxx; 

//////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_yyy; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_zzz; 

  //////////////////////////////////////////////////////////

  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xxy; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xxz; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_yyx; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_yyz;   

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_zzx; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_zzy;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xyy;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xzz;   

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_yzz; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_xyz;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_yxz;

  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors for the random catalogue used by the Yamamoto-Blake (fftw-based) estimator
   */
  vector<double> data_r_zxy;   
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief  Vectors used in the estimator of the FKP variance of pwoer spectrum
   */
  vector<double> SN;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the estimator of the FKP variance of pwoer spectrum
   */
  vector<double> Q;

  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////  
  //////////////////////////////////////////////////////////  
  //////////////////////////////////////////////////////////
  
  /**
   * @brief  Vectors used in the Bispectrum
   */
  vector<int> Arraykx;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum. Contains the MAS correction for each mode
   */
  vector<double> Array_corr;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */
  vector<int> Arrayky;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */
  vector<int> Arraykz;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */
  vector<int> Arraykk;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */
  vector<int> VecArray;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   * Number of modes per shell for the Bispectrum
   */

  vector<int> Bmodes;


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */

  vector<int> kkminID;


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */

  vector<double> kbins_bk;


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   */

  vector<int> Ngrids_bk;



  //////////////////////////////////////////////////////////
  /**
   * @brief  Vector used in Bispectrum
   */

  vector<int> ArrayID;

  //////////////////////////////////////////////////////////
  /**
   * @brief  Vector used in Bispectrum
   */
  vector<vector<double>> iFT_output_delta_full;
  
  
  //////////////////////////////////////////////////////////
  /**
   * @brief  Vector used in Bispectrum
   */
  vector<vector<double>> iFT_output_triangles_full;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief  Vector used in Bispectrum. 
   */
  vector<vector<double>> iFT_shot_noise_p1_cyc_sum_full;
    


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors used in the Bispectrum
   * Assigns to each vector in K-space the shell in which it's found
   */
  vector<int> Kbin;


  //////////////////////////////////////////////////////////
  /** 
   * @brief Complex vector for the output of the FFTW for the fluctuation 
   */
  fftw_complex *data_out_g; 


  //////////////////////////////////////////////////////////
  /**
   * @brief Complex vector for the output of the FFTW for the fluctuation, used for the crossed power
   */
  fftw_complex *data_out_gp;


  //////////////////////////////////////////////////////////
  /** 
      @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xx; 

  //////////////////////////////////////////////////////////
  /** 
   *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yy; 

  //////////////////////////////////////////////////////////
 /** 
      @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_zz; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xy; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xz; 

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yz; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xxx; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yyy; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_zzz; 

  //////////////////////////////////////////////////////////
 /** 
  *  @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xxy; 
  
  //////////////////////////////////////////////////////////
  /** 
   *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
   */
  fftw_complex *data_out_g_xxz; 
  
  //////////////////////////////////////////////////////////
  /** 
   *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yyx; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yyz;   

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_zzx; 

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_zzy;

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xyy;

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xzz;   

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yzz; 

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_xyz;

  //////////////////////////////////////////////////////////
 /** 
  *   @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_yxz;

  //////////////////////////////////////////////////////////
 /** 
  *    @brief Complex vector for the output of the FFTW used by the Yamamoto-Blake estimator 
  */
  fftw_complex *data_out_g_zxy;   

  //////////////////////////////////////////////////////////
  /** 
   *   @brief Complex vector for the output of the FFTW 
   */
  fftw_complex *data_out_r; 
  
  //////////////////////////////////////////////////////////
  /** 
   *  @brief Complex vector for the output of the FFTW used in the FKP estimation of the variance
   */
  fftw_complex *data_out_SN;

  //////////////////////////////////////////////////////////
    /** 
   *  @brief Complex vector for the output of the FFTW used in the FKP estimation of the variance
   */
  fftw_complex *data_out_Q;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_g_out_y0;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_g_out_y2;

  //////////////////////////////////////////////////////////
  /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_g_out_y4;

  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_r_out_y0;

  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_r_out_y2;

  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector< complex<double> > data_r_out_y4;

  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> SN_g_out_y2;
  
  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> SN_g_out_y4;

  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> SN_r_out_y2;

  //////////////////////////////////////////////////////////  
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> SN_r_out_y4;
  
  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> data_g_y0;
  
  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> data_g_y2;
  
  //////////////////////////////////////////////////////////
   /**
   * @brief Vector for moments in Yamamoto direct sum approach
   */
  vector<double> data_g_y4;
  
  //////////////////////////////////////////////////////////
    /** 
   * @brief Healpix object used when nbar is not tabulated
   */

#ifdef HEALPIX
  pointing point;
#endif
  //////////////////////////////////////////////////////////
  /**
  * @brief Mass assignment scheme. 
  * @details Three different MAS     
  * are available for interpolation of the density  
  * field. 
  * @params x Cartesian coordinate 
  * @returns Value of the kernel function according to the MAS selected
  */
  double MAS(double x);  
  //////////////////////////////////////////////////////////
  /**
   * @brief Estimation of the variance of the power spectrum 
   * @details using  the FKP estimator with the exact expression, equation 
   * 2.4.6  of FKP paper
   */
  void do_fkp_error_bars_exact(s_parameters_box *, vector<double> &, vector<double> &, vector<double> &,vector<double> &);
  //////////////////////////////////////////////////////////
  /**
   * @brief Computes the variance in the power spectrum 
   * @details as an approximation to the original FKP  estimation, introducing 
   * the definition of the effective volume. This is computed 
   * using the random catalogue.
   * @return Effective volume as a function of k:      
   */
  void do_fkp_error_bars_veff(s_parameters_box *, s_data_structure *, vector<double> &,vector<double> &);
  //////////////////////////////////////////////////////////

  bool measure_cross;
  

 public:


  /** 
   * @brief Default constructor
   */
  FftwFunctions(){} 
  
  /** 
   * @brief Constructor: 
   * @param _statistics statistics to be measured
   * @param _NFT number of grid cells of mesh
   */
  FftwFunctions(string _statistics, int _Nft, bool _measure_cross){statistics=_statistics;Nft=_Nft;measure_cross=_measure_cross;}

  //////////////////////////////////////////////////////////  
  /**
   * @brief Destructor
   */
  ~FftwFunctions(){}


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors for the galaxy catalogue
   */
  vector <double> data_g;


  //////////////////////////////////////////////////////////
  /**
   * @brief  Vectors for the galaxy catalogue used in case a cross power spectrum is to be measured
   */
  vector <double> data_gp;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Number of galaxies  
   */
  int n_gal;   


  //////////////////////////////////////////////////////////
  /** 
   * @brief Product of NFT^2 
   */
  int Nft2;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Product of NFT^3 
   */
  int NT;
  //////////////////////////////////////////////////////////
  /**
      @brief Parameter used to compute the normalization in power spectrum
  */
  double normal_power;
  //////////////////////////////////////////////////////////
  /** 
   * @brief Product of N1*N2*(N3/2+1) 
   */
  int NTT;

  //////////////////////////////////////////////////////////
  /** 
   * @brief inverse of deltax/y/z, used in grid_assignment
   */
  double deltax, deltay, deltaz;
  double rdeltax, rdeltay, rdeltaz;
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Number of Fourier shells in the final output of P(k) 
   */  int Nnp_data;
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Number of Fourier shells in the final output of W(k) 
   */
  int Nnp_window;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Type of binning in Fourier space
   */
  string binning;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Lengh (in Mpc/h) of each side the box in configuration space 
   */
  double Lside;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Lengh (in Mpc/h) of each side the box in configuration space 
   computed from the catalog
  */
  double Lside_data;
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Size (in h/Mpc) of fundamental mode in the z-direction 
   */
  double deltak_x; 

  //////////////////////////////////////////////////////////
  /** 
   * @brief Size (in h/Mpc) of fundamental mode in the z-direction 
   */
  double deltak_y;  
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Size (in h/Mpc) of fundamental mode in the z-direction 
   */
  double deltak_z;  

  //////////////////////////////////////////////////////////
  /** 
   * @brief Size (in h/Mpc) of fundamental mode in the radial direction 
   */
  double deltak_0;  
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Width of the spherical shell (in h/Mpc) for the power spectrum 
   */
  double DeltaK_data;  
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Width of the spherical shell (in h/Mpc) for the window function 
   */
  double DeltaK_window;



  //////////////////////////////////////////////////////////
    /**
     * @brief  Poisson Shot noise
     */
    double shot_noise;



  //////////////////////////////////////////////////////////
  /**
   * @brief Minimum wavenumber (in h/Mpc) for log binnig 
   */
  double kmin; 

  //////////////////////////////////////////////////////////
  /**
   * @brief Maximum wavenumber (in h/Mpc) for log binnig 
   */
  double kmax;

  //////////////////////////////////////////////////////////
  /**
   * @brief Maximum wavenumber (in h/Mpc) for Yamamoto estimator direct sum 
   */  
  double kmax_y_ds;
  
    //////////////////////////////////////////////////////////
  /** 
   * @brief Multiples of the fundamental mode for the power spectrum
   */
  int ndel_data;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief
   Multiples of the fundamental mode for the window function
  */
  int ndel_window;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Width of the spherical shell (in h/Mpc) for log-binning 
   */
  double Deltal;

  //////////////////////////////////////////////////////////
  /**
   * @brief Width of mu bins
   */
  double Deltamu;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Number of bins in mu
   */
  double N_mu_bins;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief  Number of log bins
   */
  int N_log_bins;

  //////////////////////////////////////////////////////////
  /**
   * @brief Nside for Healpix
   */
  int nside;

  //////////////////////////////////////////////////////////
  /**
   * @brief Number of shells for the estimation of Bk as done by Jennifer
   */
  int Nshells_bk;

  //////////////////////////////////////////////////////////
  /**
   * @brief Number of shells for the estimation of Bk as done by Jennifer
   */
  double kmax_bk;
  //////////////////////////////////////////////////////////
  /**
   * @brief Number of shells for the estimation of Bk as done by Jennifer
   */
  double kmin_bk;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Number of pixels according to the Nside value 
   */
  long npixels;

  //////////////////////////////////////////////////////////
  /**
   * @brief Area of one Healpix pixel
   */
  double area_pixel;

  //////////////////////////////////////////////////////////
  /**
   * @brief Width of the spherical shell (in h/Mpc) used int he estimates of Bispectrum
   */
  double DeltaK_Bis;

  
  ///////////////////////////////////////////////////////
  /**
   * @brief Transform the coordinates of the input catalogues to cartessian coordinates
   * @details returning the same input vector in which the three first columns correspond to
   * to the X,Y,Z coordinates and in the i_nbar (see input parameter file)
   * the mean number density is written.
   *
   * @param s_b: structure containing parametrs of the Fourier box
   * @param s_d structure containing information related to the catalogue
   * @param cat: 2d container with the catalog 
   * @result Catalogue with position in cartesian coordinates and mean number density
   * tabulated in the corresponding column as stated in the parameter file
   */
  void cart_coordinates(s_parameters_box *s_b, s_data_structure *s_d, vector< double >&cat); 
  ///////////////////////////////////////////////////////
  /**
   * @brief Pass the parameters associated to the DFT
   */
  
  void set_pars(double lside,double kmaxys, int ndeld, int ndelw, int Nlogbins, int Nmubins, bool mas_cor,string mas, double kmin_bk,double kmax_bk);
  
  
  ///////////////////////////////////////////////////////
  /**
   * @brief Assign the Healpix resolution to the private variable of this class
   */
  
  void set_healpix_pars(int Nres);

  ///////////////////////////////////////////////////////
  /**
   * @brief Computes the parameters of the k-bins
   * @details such as width, kmin, kmax, etc according to the type of binning
   * @param type_of_binning: set the type of binning in k-space (linear, log)
   * @result Computes the bin-width:
   * deltak_x, 
   * deltak_y, 
   * deltak_z, 
   */
  void set_bins(string type_of_binning);
  
  ///////////////////////////////////////////////////////
  /**
   *@brief Row-major (or c) ordering of the FFTW output
   * @details Based on the indices i, j, k (in 0<i<n1-1)
   * this function returns the label corresponding
   * to a row-major (or c) ordering of the FFTW output
   * @param i x-grid coordinate
   * @param j y-grid coordinate
   * @param k z-grid coordinate
   * @param n1 number of cells in the x-direction
   * @param n2 number of cells in the y-direction
   * @param n3 number of cells in the z-direction
   * @result Row-major index in the grid
   */
  // try: define it as a macro
  // int ijk(int i, int j, int k, int n1, int n2, int n3);
  //////////////////////////////////////////////////////////
  /**
   *@brief Compute the total statistical weight of a given galaxy
   * @details Compute the total weight from the available statistical     
   * weights present in the catalogs.    
   * @param uw: bool vector indicating whether a weight is used or not. 
   * @param ow: double vector with the value of the weight
   * @param t_weight: total weight computed as the product of weights chosen to be used
   * @result Total statistical weight for a particular galaxy
   * @note The code accepts four (4) different weights (per galaxy)
   * plus the FKP weights. See input parameter file.
   */  
  void get_total_weight(vector<bool>&uw, vector<double> &ow, double*t_weight);

  //////////////////////////////////////////////////////////
  /** 
   * @brief Resizes and initializes the input and 
   * output vectors for the FFTW 
   */
  void fftw_vectors();
  //////////////////////////////////////////////////////////
  /**
   * @brief Interpolation of the object density field into a grid.
   * @details  Interpolation of the galaxy overdensity field.                    
   * Periodic bounday conditions are applie to remap objects 
   * with coords. outside the range [0,Lx] within the box  
   * @param x  x-coordinate of galaxy
   * @param y y-coordinate of galaxy
   * @param z z-coordinate of galaxy
   * @param weight weight 
   * @param dat vector containing the interpolated galaxy distribution
   */                          
  void grid_assignment(double x, double y, double z, double *weight, pic_storage **data, int, int);
  //////////////////////////////////////////////////////////
  /**
   * @brief Sampling of galaxy catalogue
   * @details according to selected MAS
   * @param s_b structure of type s_parameters_box
   * @param s_d structure of type s_data_structure
   * @result Generates private class members: vectors ready to be Fourier transformed
   */
  void get_interpolated_density_field(s_parameters_box *s_b, s_data_structure *s_d);
  //////////////////////////////////////////////////////////
  /**
   * @brief Constant density grid assignment
   * @details Function used when no random catalogue is implemented.
   * A vector is filled with the mean number density of
   * the simulation. Such mean number density is computed
   * from the information if the size of the box
   * as given in the parameter file, together with the 
   * number of objects. 
   * @param vol Volumen of the sample if known
   * @result Private class member containing the galaxy fluctuation interpolated in the mesh of size NFT.
   */
  void raw_sampling(double vol);
  //////////////////////////////////////////////////////////
  /**
   * @brief Build FKP fluctuation
   * @details Build the galaxy fluctuation by subtracting data 
   * and random catalogue with factor alpha
   * @params vol Volume of the box
   */
  void get_fluctuation();
  //////////////////////////////////////////////////////////  
  /**
   * @brief Computes the parameters associated to the
   * FKP estimator
   * @details e.g., normalization, shot noise, etc.
   * and assign them to public/or private variables of this class.
   * @ parameter ur Use random catalogue (true/false)
   */
  void get_parameters_estimator(bool ur);

  //////////////////////////////////////////////////////////
  /**
   * @brief Correction for the mass assignment scheme
   * @details Cormode by mode.
   * @param  i kx-coordinate in Fourier space (in units of the fundamental mode)
   * @param  j ky-coordinate in Fourier space (in units of the fundamental mode)
   * @param  k kz-coordinate in Fourier space (in units of the fundamental mode)
   * @return Squared of the Fourier transform of the mass assignment scheme at the position (i,j,k) in Fourier space
   */
  double correction_MAS(int i, int j, int k);

  //////////////////////////////////////////////////////////
  /**
   * @brief Shell average in Fourier space. 
   * @details This function returns the spherical average estimate 
   * of the monopole, quadrupole, hexadecapole, and the 
   * window function of based on the FKP estiamtor.
   * For the spherical averages, we only use a quarter of the full FOURIER box,   
   * using Hermitian symmetry F(kx, ky, -kz)=F(-kx, -ky, kz)* to      
   * recover the  information in the negative frequencies explicitely.
   * When counting modes and power, we weight by a factor 2           
   * order to account for the negative z-quadrant. Although           
   * the factor 2 cancels out when computing the average power in each
   * shell this allows comparisons with codes using the full box.     
   * This subroutine is ideal also for the multipole decomposition    
   * in the modes l=0, 2 and 4. For other moments, the full excusrion   
   * through Fourier space has to be done.
   * BINNING: the floor function ensures that we are using intervals          
   * of the form [). The spherical shells are such that the first bin 
   * starts at the zero frequency (althought that mode is exlcuded    
   * for the power spectrum, not for the window function),            
   * Note therefore that in the case ndel=1, the fist bin             
   * will contain ONLY one Fourier mode, is the zero frequency.       
   * Therefore, it is convinient to start with ndel=2                 
   * This function is called by get_power_spectrum_fkp().
   * @param s_b structure of type s_parameters_box
   * @return p_g0 monopole power spectrum
   * @return p_g2 quadrupole power spectrum
   * @return p_g4 hexadecapole power spectrum
   * @return p_r power spectrum of the window function
   * @return p_2d 2d power spectrum in cartesian coordinates
   * @return p_2s 2d power spectrum in polar coordinates
   * @return nm Number of modes in spherical shells 
   */
  void power_spectrum_fkp(s_parameters_box *s_b, vector<double>&p_g0, vector<double>&p_g2, vector<double>&p_g4,vector<double>&p_r, vector< vector<double> >&p_2c, vector< vector<double> >&p_2s, vector<int>&nm);

  void power_spectrum_fkp(s_parameters_box *s_b, vector<double>&p_g0,vector<int>&nm);

  
  //////////////////////////////////////////////////////////
  /**
   * @brief Shell average in Fourier space for Bispectrum
   * @param s_b structure of type s_parameters_box
   * @return p_g0 monopole power spectrum

   */
  void power_spectrum_fkp_for_bispectrum(s_parameters_box *s_b, vector<double>&p_g0);




  //////////////////////////////////////////////////////////
  /**
   * @brief Shell average in Fourier space. 
   * @details This function returns the spherical average estimate 
   * of the monopole, quadrupole, hexadecapole, based on the Yamamoto estimator.
   * For the spherical averages, we only use a quarter of the full FOURIER box,   
   * using Hermitian symmetry F(kx, ky, -kz)=F(-kx, -ky, kz)* to      
   *  recover the  information in the negative frequencies explicitely.
   *  When counting modes and power, we weight by a factor 2           
   *  order to account for the negative z-quadrant. Although           
   *  the factor 2 cancels out when computing the average power in each
   *  shell this allows comparisons with codes using the full box.     
   *  This subroutine is ideal also for the multipole decomposition    
   *  in the modes l=0, 2 and 4. For other moments, the full excurion   
   *  through Fourier space has to be done.
   *  This function is called by get_power_spectrum_yamammoto().
   * @param s_b structure of type s_parameters_box
   * @return p_g0 monopole power spectrum
   * @return p_g2 quadrupole power spectrum
   * @return p_g4 hexadecapole power spectrum
   * @return mod Number of modes in spherical shells 
   */
  void power_spectrum_yamamoto(s_parameters_box *s_b, vector<double>&p0, vector<double>&p2, vector<double>&p4,vector<int>&mod);
  void _power_spectrum_yamamoto(s_parameters_box *s_b, vector<double>&p0, vector<double>&p2, vector<double>&p4,vector<int>&mod);
  
  

  //////////////////////////////////////////////////////////
  /**
   *@brief  Compute the multipole decomposition using FKP estimator
   * @param s_b structure of type s_params_box
   * @return p0 monopole power spectrum
   * @return p2 quadrupole power spectrum
   * @return p4 hexadecapole power spectrum
   * @return pr power spectrum of the window function
   * @return p2d TwoD power spectrum in cartesian coordinates
   * @return p2s TwoD power spectrum in polar coordinates 
   * @return nm Number of modes in spherical shells 
  */
  void get_power_spectrum_for_bispectrum(s_parameters_box *s_b,vector<double>&p0);

  //////////////////////////////////////////////////////////
  /**
   *@brief  Compute the multipole decomposition using FKP estimator
   * @param s_b structure of type s_params_box
   * @return p0 monopole power spectrum
   * @return p2 quadrupole power spectrum
   * @return p4 hexadecapole power spectrum
   * @return pr power spectrum of the window function
   * @return p2d TwoD power spectrum in cartesian coordinates
   * @return p2s TwoD power spectrum in polar coordinates 
   * @return nm Number of modes in spherical shells 
  */
 void get_power_spectrum_fkp(s_parameters_box *s_b,vector<double>&p0,vector<double>&p2,vector<double>&p4, vector<double>&pr, vector<vector<double> >&p2d,  vector<vector<double> >&p2s,vector<int>&nm);

 void get_power_spectrum_fkp(s_parameters_box *s_b,vector<double>&p0,vector<int>&nm);

 
 //////////////////////////////////////////////////////////
 /**
  *@brief  Compute the multipole decomposition using Yamamoto estimator
  *@details with the FFTW based scheme.
  * @param s_b structure of type s_params_box
  * @result p0 monopole power spectrum
  * @result p2 quadrupole power spectrum
  * @result p4 hexadecapole power spectrum
  * @result p_r power spectrum of the window function
  * @result nm Number of modes in spherical shells 
  */
 void get_power_spectrum_yamamoto(s_parameters_box * s_b,vector<double>&p0,vector<double>&p2,vector<double>&p4,vector<int>&nm);
 
 //////////////////////////////////////////////////////////
  /**
   * @brief Estimates of the variance for the power spectrum
   * @details based on the FKP estimator. Selects between the 
   * exact and the approximate expression for the var(P)
   * @param s_b structure of type s_params_box
   * @param s_d structure of type s_data_structure
   * @param kv k-spherical shells
   * @param pk power spectrum in k-spherical shells
   * @param nm number of modes in k-spherical shells
   * @result sig FKP variance of the power spectrum
   */
  void get_fkp_error_bars(s_parameters_box *s_b,  s_data_structure *s_d, vector<double> &kv, vector<double> &pk, vector<int>&nm, vector<double> &sig);
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Generate an interpolated value of the mean number density           
   * @details given the position in the sky of the object, when the depth        
   * varies with the angular position. This interpolates the matrix     
   * computed on the method dndz          
   * @param s_b structure of type s_parameters_box
   * @param zmin Minimum redshift of the sample
   * @param zmax Maximum redshift of the sample
   * @param ra Right ascencion of the galaxy   
   * @param ra Declination of the galaxy
   * @param zg Redshift of the galaxy
   * @param dndz_m container with the vaues of the mean number density in redshift bins and Healpix pixels tabulated.
   * @result nbar Mean number denisiy tabulated at the position of the galaxy
   */
  void get_mean_density_interpolated(double zmin, double zmax, double ra, double dec, double zg, vector< vector<double> >&dndz_m, double *nbar);


  
  //////////////////////////////////////////////////////////
  /**
   * @brief Count of triangles in Fourier space 
   * @details 
   */
  void bispectrum_fkp(char, s_parameters_box *s_p, vector<double> &, vector<double> &, vector<double> &, vector<int> &); 
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Map indices between different DFT output schemes
   * @details This auxiliary function returns the indices that are 
   * arguments of the function ijk(), used to retrieve the 
   * amplitudes of the DTF as given by the FFTW. This takes into account   
   * the fact that we are adding one more frequency, 
   * the -Nyquist to the outpu and that we use Hermitian 
   * symmetry to retrieve the negative section       
   * of the third component, i.e, 
   * delta(kx, ky, -kz)=delta(-kx, -ky, kz)*    
   * @param s_b structure of type s_parameters_box
   */
  void remap(int, int, int, int , int , int , int *, int *, int *, double *);
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Estimates of Bispectrum   
   * @details  based on the counts of triangles                      
   * the normalization and the shot-noise corrections.
   * @param s_b structure of type s_parameters_box
   */  
  void get_bispectrum_fkp(char, s_parameters_box *s_p, vector<double> &, vector<double> &, vector< int > &);


  //////////////////////////////////////////////////////////
  /**
   * @brief Estimates of Bispectrum   
   * @details  based on trick by Scoccimarro and Jennifer                      
   * @param s_b structure of type s_parameters_box
   */  
  void get_bispectrum_fkp_fast(s_parameters_box *s_p, vector<double> &, vector<double> &, vector< int > &, string file);
  
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Define k-shells for the estimation of bispectrum
   * @param s_b structure of type s_parameters_box
   */  
  void define_kshells(s_parameters_box *s_box);


  //////////////////////////////////////////////////////////
  /**
   * @brief Get the inverse Fourier transform in each Fourier shell 
   * @param Pass the definition of binning
   */  
  void get_ift_shells_bispectrum(s_parameters_box *s_box);


  //////////////////////////////////////////////////////////
  /**
   * @brief Define k-shells for the estimation of bispectrum
   * @param s_b structure of type s_parameters_box
   */  
  void loop_shells_bispectrum(s_parameters_box *s_box, vector<double> &pk, vector<double> &bispect, vector< int > &mod, string file);



  //////////////////////////////////////////////////////////
  /**
   * @brief Define k-shells for the estimation of bispectrum
   * @param s_b structure of type s_parameters_box
   */  
  void construct_shells(int ngrid, int kmnid, int kmxid, vector<double> &iFT_output_delta, vector<double> &iFT_output_triangles,vector<double> &iFT_output_p1_cyc_sum);


  //////////////////////////////////////////////////////////
  /**
   * @brief Mapping of vectos from one octant to the octants in the kz>0 sub-volume of Fourier space 
   * @param s_b structure of type s_parameters_box
   */  
 
  void cellsym(int id, int ngrid,fftw_complex *data_ks, fftw_complex *data_dk,fftw_complex *data_pk_sn);
  
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Evaluates the DFT required for the estimates of 
   * multipole decomposition 
   * @details of the power spectrum using the Yamamoto-Blake estimator 
   * obtained from a direct-sum approach
   * @param s_b structure of type s_parameters_box
   * @param s_d structure of type s_data_structure
   */
  void get_power_moments_fourier_grid_ds_yam(s_parameters_box *d_b, s_data_structure *s_d);
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Compute shell-averaged multipole decomposition of the 
   * power spectrum obtained from the  Yamamoto-Blake estimator 
   * implemening a a direct-sum approach. 
   * @param s_b structure of type s_parameters_box
   * @result p0 monopole
   * @result p2 quadrupole
   * @result p4 hexadecapole
   * @result nm number of modes in spherical shell
   */
  
  
  void power_yam_1d_ds(s_parameters_box *s_box, vector<double>&p0 ,vector<double>&p2 ,vector<double>&p4, vector<int> &nm);


  //////////////////////////////////////////////////////////
  /**
   * @brief Write parameters on screen
   */  
  void write_fftw_parameters();


  //////////////////////////////////////////////////////////
  /**
   * @brief Write parameters on .log file
   * @param p void pointer
   * @param log_f log file
   */  
  void write_fftw_parameters(void *p, string log_f);

};





#endif





