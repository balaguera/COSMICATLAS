 /**
 * @class <PowerSpectrumF>
 * @brief Header file for the class PowerSpectrum::
 * @file PowerSpectrumF.h
 * @author Andres Balaguera-Antol√≠nez
 * @version 1.0
 * @date  2020
 * @details This file defines the interface of the class PowerSpectrum, used to
 *  obtain the measurements of Power spectrum (3D, Angular).
 */


#ifndef __POWERSPECTRUM__
#define __POWERSPECTRUM__

#include "Params.h"
#include "FileOutput.h"
#include "Catalog.h"
#include "DnDz.h" 
#include "CoordinateSystem.h" 
#include "FftwFunctions.h"
#include "ScreenOutput.h"

using namespace std;

class PowerSpectrumF{


 private :

  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  Catalog tracer_cat;
   //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  Catalog random_cat;
  //////////////////////////////////////////////////////////
  /**
   *  @brief get the value of the private member
   *  PowerSpectrum::pk4
   *  @param i index of the vector pk4
   *  @return PowerSpectrum::pk4[i]
   */
  Params params;
  //////////////////////////////////////////////////////////
  /** 
   * @brief Object of type CosmologicalFunctions 
   */
  Cosmology c_Cf;
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Object of type FileManager 
   */
  FileOutput c_Fm;

  //////////////////////////////////////////////////////////
  /** 
   * @brief Object of type OpStatistics
   */
  DnDz c_Op;
  
  //////////////////////////////////////////////////////////
  /** 
   * @brief Object of type ScreenOutput
   */
  ScreenOutput So;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Object of type GalaxyOperations
   */
  CoordinateSystem c_gal;
  //////////////////////////////////////////////////////////
  /**
   *  @name private variables for power spectrum
   *  @brief
   */
  vector<real_prec> kvector_data;
  
  //////////////////////////////////////////////////////////
  /**
   *  @name Vector containing the k identifying spherical shells for the estimates pf the window function
   *  @brief
   */
  vector<real_prec> kvector_window;
  
  //////////////////////////////////////////////////////////
  /**
   * @brief Vector containing the k identifying spherical shells for the estimates of power spectrum* in 2d cart 
   */
  vector<real_prec> kvector_data2d;
  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> muvector;
  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> pk0;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> pk2;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> pk4;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> pk_w;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<int> modes_g; 
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector < vector<real_prec> > pkk;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector < vector<real_prec> > pmk;
    //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> sigma_fkp;
    //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> sigma_y_l2;
    //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> sigma_y_l4;
 //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> kvector_data_b;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> bispectrum;
 //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<real_prec> sn_bispectrum;
   //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  vector<int> modes_tri;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string rest_file;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  ULONG nside;
    //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  long N_random;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_random; 
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_dndz;   
  //////////////////////////////////////////////////////////
    /**
   *  @brief 
   */
  string file_power;  
 //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_power_real_space;  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_power_redshift_space;  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_MCF;  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_power_log;  
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_power2d; 
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_power2d_mk;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_window; 
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string file_bispectrum;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  real_prec mean_density;
 //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  bool use_random_catalog_cl;
 //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  int Nbins_r;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  real_prec rmin;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  real_prec rmax;
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  string r_bin_type;
 

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
 public :

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /**
   *  @brief Default constructor
   *  @return object of PowerSpectrum
   */
  PowerSpectrumF ():N_random(0),mean_density(0),Nbins_r(0),rmin(0),rmax(0){
      time_t time_bam;
      time(&time_bam);
      this->So.initial_time=time_bam;
 }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /**
   *  @brief Constructor 
   *  @param params 
   */
  PowerSpectrumF (Params &_params): params(_params),N_random(0),mean_density(0),Nbins_r(0),rmin(0),rmax(0)
  {
     this->set_output_filenames();
     time_t time_bam;
     time(&time_bam);
     this->So.initial_time=time_bam;
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /**
   *  @brief Default destructor
   *  @return none
   */
  ~PowerSpectrumF () {}
  //////////////////////////////////////////////////////////
#if defined (_USE_MASS_CUTS_PK_)  || defined (_USE_ALL_PK_)
  void add_catalogues(real_prec mcuts);
#elif defined (_USE_MASS_BINS_PK_)
  void add_catalogues(real_prec m_min, real_prec m_max);
#endif
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  vector< real_prec > galaxy_catalog;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  vector< real_prec > random_catalog;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  int rc_n_columns;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  int gc_n_columns;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  string file_data;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  long N_galaxy;
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  real_prec shot_noise;
   //////////////////////////////////////////////////////////
  /**
   * @brief Compute the Power_Spectrum and/or the Bispectrum
   * @details This function generates the estiametes of power spectrum ()
   *  (FKP, Yamamoto and their multipole decomposition) and the Bispectrum
   *  (using FKP).
   * @arg verbose use dto write on screen
*/
  void compute_power_spectrum (bool verbose, bool mcuts);
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the Power_Spectrum and/or the Bispectrum
   * @details This function generates the estiametes of power spectrum ()
   *  (FKP, Yamamoto and their multipole decomposition) and the Bispectrum
   *  (using FKP).
*/

  void compute_power_spectrum (bool verbose, vector<s_Halo>&tracer);
  //////////////////////////////////////////////////////////
  /**
   * @brief This two functions perform the same tasks as compute_power_spectrum (bool verbose, vector<s_Halo>&tracer);, but this is called form bam.
   * and explicitily made for measuring power in real and/or redshift space.
*/

  void compute_power_spectrum_bam_real_space (vector<s_Halo>&tracer);
  //////////////////////////////////////////////////////////
  /**
   * @brief This two functions perform the same tasks as compute_power_spectrum (bool verbose, vector<s_Halo>&tracer);, but this is called form bam.
   * and explicitily made for measuring power in real and/or redshift space.
*/
  void compute_power_spectrum_bam_redshift_space(vector<s_Halo>&tracer);
  //////////////////////////////////////////////////////////
  /**
   * @brief This two functions perform the same tasks as compute_power_spectrum (bool verbose, vector<s_Halo>&tracer);, but this is called form bam.
   * and explicitily made for measuring power in real and/or redshift space.
*/
  void compute_power_spectrum_bam(vector<s_Halo>&tracer, string space);

  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the Power_Spectrum and/or the Bispectrum
  */
  void compute_power_spectrum_grid();
  //////////////////////////////////////////////////////////
  /**
   * @brief 
  */
  void compute_marked_correlation_function ();
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the Power_Spectrum and/or the Bispectrum
   * @details This function generates the estiametes of power spectrum ()
   *  (FKP, Yamamoto and their multipole decomposition) and the Bispectrum
   *  (using FKP).
   */
  void compute_power_spectrum_grid(const vector<real_prec>&);
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the Marked Power_Spectrum
   */
  void compute_marked_power_spectrum_grid(const vector<real_prec>&, const vector<real_prec>&);
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the cross power spectrum between fields X and Y
    * @param dm bool set to true if X is dark matter so no shot-noise is computed for that component
 */
  void compute_cross_power_spectrum_grid(bool dm, vector<real_prec>&X,vector<real_prec>&Y);
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the cross power spectrum between fields X and Y
    * @param dm bool set to true if X is dark matter so no shot-noise is computed for that component
 */
  void compute_cross_power_spectrum_grid(bool dm, string file_X,string file_Y);
  //////////////////////////////////////////////////////////
  /** 
   * @brief Write output of power spectrum and/or bispectrum 
   * @details computed in the function compute_power_spectrum()
   */
  void write_power_spectrum ();

  //////////////////////////////////////////////////////////
  /** 
   * @brief Write output of power spectrum and/or bispectrum 
   * @param write sigma yes/no.
   */
  void write_power_spectrum (bool);
  //////////////////////////////////////////////////////////
  /** 
   * @brief Write output of power spectrum and/or bispectrum 
   * @param write sigma yes/no.
   */
  void write_power_and_modes();
  //////////////////////////////////////////////////////////
  /** 
   * @brief Write output of power spectrum and/or bispectrum 
   * @param write sigma yes/no.
   */
  void write_power_and_modes(string);
  //////////////////////////////////////////////////////////
  /** 
   * @brief Write output of power spectrum and/or bispectrum 
   * @details computed in the function compute_power_spectrum()
   */
  void write_power_spectrum_grid(string);
  //////////////////////////////////////////////////////////
  /**
   * @brief Compute the angular power spectrum in bins of redshift
   * @details using the Peebles estimator and the Healpix package
   */
  void compute_cl_power_spectrum ();  
  //////////////////////////////////////////////////////////
 /**
   * @brief Write output of angular power spectrum in redshift bins
   */
  void write_cl_power_spectrum ();
  //////////////////////////////////////////////////////////
 /**
   * @brief 
   */
   void set_parameters_power();
  //////////////////////////////////////////////////////////
  /**
   *  @brief Set the values of the private variables that regard filenames - with one catalogue
   */
  void set_output_filenames();
  //////////////////////////////////////////////////////////
  /**
   *  @brief get the value of the private member 
   *  PowerSpectrum::kvector_data
   *  @param i index of the vector kvector_data
   *  @return PowerSpectrum::kvector_data[i]
   */
  real_prec _kvector_data (int i) { return kvector_data[i]; }
 //////////////////////////////////////////////////////////
  /**
   *  @brief get the size of the private member
   *  PowerSpectrum::kvector_data
   *  @return PowerSpectrum::kvector_data.size()
   */
  int _kvector_data_size () { return kvector_data.size(); }
  ////////////////////////////////////////////////////////// 
  /**
   *  @brief get the value of the private member 
   *  PowerSpectrum::pk0
   *  @param i index of the vector pk0
   *  @return PowerSpectrum::pk0[i]
   */
  real_prec _pk0 (int i) { return pk0[i]; }
  ////////////////////////////////////////////////////////// 
  /**
   *  @brief get the value of the private member 
   *  PowerSpectrum::modes
   *  @param i index of the vector pk0
   *  @return PowerSpectrum::pk0[i]
   */
  real_prec _nmodes_k (int i) { return modes_g[i]; }
  //////////////////////////////////////////////////////////
  /**
   *  @brief get the value of the private member 
   *  PowerSpectrum::pk2
   *  @param i index of the vector pk2
   *  @return PowerSpectrum::pk2[i]
   */
  real_prec _pk2 (int i) { return pk2[i]; }

  ////////////////////////////////////////////////////////// 
  /**
   *  @brief get the value of the private member 
   *  PowerSpectrum::pk4
   *  @param i index of the vector pk4
   *  @return PowerSpectrum::pk4[i]
   */
  real_prec _pk4 (int i) { return pk4[i]; }

  //////////////////////////////////////////////////////////
  /**
   *  @brief get the value of the private member
   *  PowerSpectrum::pk4
   *  @param i index of the vector pk4
   *  @return PowerSpectrum::pk4[i]
   */
  real_prec _sigma_fkp (int i) { return sigma_fkp[i]; }
  //////////////////////////////////////////////////////////
  /**
   *  @brief 
   */
  real_prec var_prop;

};

#endif
