/** @file PowerSpectrumF.cpp
 *
 * @brief This file contains a public PowerSpectrum-class member function
 * @details Generates thee estimates of power spectrum
 * @author Andres Balaguera Antolinez
 */



#undef MINERVA
//#define MINERVA

#include "../Headers/PowerSpectrumF.h"

// *************************************************************************************
// *************************************************************************************
// *************************************************************************************
/*
  #ifdef _USE_ALL_PK_
  void PowerSpectrumF::add_catalogues()
  {
  this->tracer_cat.set_params_catalog(this->params);
  this->tracer_cat.type_of_object="TRACfER";
  this->tracer_cat.read_catalog(this->file_data,0);
  this->gc_n_columns=this->tracer_cat.NCOLS;
  this->N_galaxy=this->tracer_cat._NOBJS();

  if(true==this->params._use_random_catalog())
  {
  this->tracer_cat.set_params_catalog(this->params);
  this->tracer_cat.type_of_object="RANDOM";
  this->random_cat.read_catalog(this->file_random,0);
  this->rc_n_columns=this->random_cat.NCOLS;
  this->N_random=this->random_cat._NOBJS();
  }
  }
  #endif
*/
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
void PowerSpectrumF::set_output_filenames ()
  {
    
    file_MCF     = this->params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+".txt";

#ifdef _USE_REDSHIFT_BINS_
        params._Name_survey()+="_zmin_"+to_string(this->params._redshift_min_sample()) +"_zmax_"+to_string(this->params._redshift_max_sample());
#endif
#ifdef _REDSHIFT_SPACE_
    file_power  = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
    file_power_log      = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power_log()+"_RSS.log";   
#else
    file_power  = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt";
    file_power_log      = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power_log()+".log";   
#endif
    file_power_real_space  = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt";
    file_power_redshift_space  = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
    file_dndz           = params._dir_output()+"dndz_"+params._Name_survey()+params._file_dndz()+".txt";
    file_power2d        = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power2d()+".txt";
    file_power2d_mk     = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power2d_mk()+".txt";
    file_window         = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_window();
    file_bispectrum     = params._dir_output()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_bispectrum()+".txt";
    //file_power_fb       = file_power_cl; // ???
    file_data = params._file_catalogue();
    file_random = params._file_random();

  }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************


#if defined (_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
void PowerSpectrumF::add_catalogues(real_prec mcut)
{
#elif defined (_USE_MASS_BINS_PK_)
void PowerSpectrumF::add_catalogues(real_prec m_min, real_prec m_max)
  {
#endif

    this->So.enter(__PRETTY_FUNCTION__);


    this->tracer_cat.set_type_of_object("TRACER");

#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->tracer_cat.read_catalog(this->params._Input_dir_cat()+ this->file_data, mcut);
#elif defined (_USE_MASS_BINS_PK_)
    this->tracer_cat.read_catalog(this->params._Input_dir_cat()+file_data,m_min,m_max);
#endif
    this->gc_n_columns=this->tracer_cat.NCOLS;
    this->N_galaxy=this->tracer_cat._NOBJS();

    if(true==this->params._use_random_catalog())
      {
      	this->random_cat.set_type_of_object("RANDOM");
#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
	     this->random_cat.read_catalog(this->params._Input_dir_cat()+this->file_random, mcut);
#elif defined (_USE_MASS_BINS_PK_)
	     this->random_cat.read_catalog(this->params._Input_dir_cat()+file_random,m_min,m_max);
#endif
	     this->rc_n_columns=this->random_cat.NCOLS;
	     this->N_random=this->random_cat._NOBJS();
      }
  }


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************


  void PowerSpectrumF::write_power_spectrum() ///PLeas unify the name of this function with write_power and modes
  {
    // Write P(k) to file:

    this->So.enter(__PRETTY_FUNCTION__);


    if(this->params._statistics()=="Pk_fkp")
      {
#ifdef _WRITE_MULTIPOLES_
	c_Fm.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
#else
	cout<<"writting power"<<endl;
	c_Fm.write_to_file(this->file_power,this->kvector_data,this->pk0,this->modes_g);
#endif

	// Write P(kperp, kpar) to file:
#ifdef _WRITE_2DPOWER_
	c_Fm.write_to_file(this->file_power2d,this->kvector_data2d,this->kvector_data2d,this->pkk);
	//Write P(k, mu) to file:
	c_Fm.write_to_file(file_power2d_mk,this->muvector,this->kvector_data2d,this->pmk);
#endif
	// Write W(k):
	if(true==this->params._use_random_catalog())
	  c_Fm.write_to_file(this->file_window,this->kvector_window,this->pk_w);

      }

    else if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")
      {
	c_Fm.write_to_file(file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
      }
    else if(this->params._statistics()=="Bk_fkp")
      c_Fm.write_to_file(file_bispectrum,kvector_data_b,bispectrum,sn_bispectrum, modes_tri);
  }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::write_power_spectrum(bool write_sigma) ///PLeas unify the name of this function with write_power and modes
  {
    this->So.enter(__PRETTY_FUNCTION__);
    if(this->params._statistics()=="Pk_fkp")
      {
#ifdef _WRITE_MULTIPOLES_
        if(true==write_sigma)
            c_Fm.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
        else 
            c_Fm.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->modes_g);
#else
      cout<<"writting power"<<endl;
      c_Fm.write_to_file(this->file_power,this->kvector_data,this->pk0,this->modes_g);
#endif
  // Write P(kperp, kpar) to file:
#ifdef _WRITE_2DPOWER_
      c_Fm.write_to_file(this->file_power2d,this->kvector_data2d,this->kvector_data2d,this->pkk);
  //Write P(k, mu) to file:
      c_Fm.write_to_file(file_power2d_mk,this->muvector,this->kvector_data2d,this->pmk);
#endif
  // Write W(k):
      if(true==this->params._use_random_catalog())
        c_Fm.write_to_file(this->file_window,this->kvector_window,this->pk_w);
   }
   else if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")
    {
     c_Fm.write_to_file(file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
    }
   else if(this->params._statistics()=="Bk_fkp")
      c_Fm.write_to_file(file_bispectrum,kvector_data_b,bispectrum,sn_bispectrum, modes_tri);
  }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************


  void PowerSpectrumF::write_power_and_modes()
  {
    this->So.enter(__PRETTY_FUNCTION__);
    c_Fm.write_to_file2(this->file_power,this->kvector_data,this->pk0,this->modes_g,true);
    if(this->params._use_random_catalog())
      c_Fm.write_to_file2(this->file_window,this->kvector_data,this->pk_w,this->modes_g,true);
  }
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
  void PowerSpectrumF::write_power_and_modes(string file)
  {
    this->So.enter(__PRETTY_FUNCTION__);
    c_Fm.write_to_file2(file,this->kvector_data,this->pk0,this->modes_g, true);
  }
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::write_power_spectrum_grid(string output_file)
  {
    this->So.enter(__PRETTY_FUNCTION__);
#ifdef _FULL_VERBOSE_
    So.message_screen("Writing outputs");
#endif
    c_Fm.write_to_file(output_file,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);


  }
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::compute_marked_correlation_function()
  {

    this->So.enter(__PRETTY_FUNCTION__);
    time_t start;
    time (&start);

    cout<<CYAN<<"Measuring marked correlation function. SO FAR INPUTS ARE IN CARTESSIAN COORDINATES"<<RESET<<endl;
    cout<<CYAN<<"The info of the weight is taken from column "<<params._i_weight1_g()<<" in the input catalog "<<RESET<<endl;
#if defined (_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->add_catalogues(0);
#else
    this->add_catalogues(0,1e20);
#endif

    if(this->gc_n_columns<3)cout<<RED<<" Catalog with no extra information"<<RESET<<endl;

    vector<int>count(Nbins_r,0);
    vector<real_prec>mcount(Nbins_r,0);
    vector<real_prec> rbin(Nbins_r,0);

    real_prec Deltar=r_bin_type == "LIN"  ?   (rmax-rmin)/((real_prec)Nbins_r):  (log10(rmax/rmin))/((real_prec)Nbins_r);

    int NTHREADS =  omp_get_max_threads();
    cout<<CYAN<<"Measuring Marked Correlation function using "<<NTHREADS<<" threads ..."<<RESET<<endl;

    if(r_bin_type=="LIN")for (int i=0;i<rbin.size();++i)rbin[i]=rmin+(i+0.5)*Deltar;
    else for (int i=0;i<rbin.size();++i)rbin[i]=pow(10, log10(rmin)+(i+0.5)*Deltar);

    real_prec mean_mark=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:mean_mark)
#endif
    for (int i=0;i<this->N_galaxy;++i)
      mean_mark+=this->tracer_cat.Halo[i].weight1;

    mean_mark=(static_cast<double>(mean_mark))/(static_cast<double>(this->N_galaxy));
    cout<<CYAN<<"Mean mark = "<<BLUE<<mean_mark<<RESET<<endl;


#pragma omp parallel num_threads(NTHREADS)
    {

      vector<int> count_priv(Nbins_r,0);
      vector<real_prec> mcount_priv(Nbins_r,0);

#pragma omp for nowait
      for (int i=0;i<this->N_galaxy;++i)
	{
	  real_prec x=this->tracer_cat.Halo[i].coord1;
	  real_prec y=this->tracer_cat.Halo[i].coord2;
	  real_prec z=this->tracer_cat.Halo[i].coord3;
	  real_prec weight=this->tracer_cat.Halo[i].weight1;
	  for (int j=i+1;j<this->N_galaxy;++j)
	    {
	      real_prec xp=this->tracer_cat.Halo[j].coord1;
	      real_prec yp=this->tracer_cat.Halo[j].coord1;
	      real_prec zp=this->tracer_cat.Halo[j].coord1;
	      real_prec weightp=this->tracer_cat.Halo[j].weight1;

	      real_prec r=sqrt(pow(xp-x,2)+pow(yp-y,2)+pow(zp-z,2));
	      if(r<rmax && r>=rmin)
		{
		  int ind = r_bin_type == "LIN" ? (int)floor((r-rmin)/Deltar)  :  (int)floor((log10(r/rmin))/Deltar);
		  count_priv[ind]++;
		  mcount_priv[ind]+=(weight*weightp);
		}
	    }
	}

#pragma critical
      {
	for(int i=0;i<mcount.size();++i)mcount[i]+= mcount_priv[i];
	for(int i=0;i<count.size() ;++i) count[i]+= count_priv[i];
      }
    }

    this->tracer_cat.Halo.clear();
    this->tracer_cat.Halo.shrink_to_fit();

    So.DONE();
    cout<<CYAN<<" Done"<<RESET<<endl;

    for(int i=0;i<mcount.size();++i)mcount[i]=(mcount[i]/( pow(mean_mark,2)*(real_prec)count[i]));
    for(int i=0;i<mcount.size();++i)cout<<rbin[i]<<"  "<<mcount[i]<<"  "<<count[i]<<endl;

    string ov_name= file_MCF;
    ofstream mcor; mcor.open(ov_name.c_str());
    mcor.precision(6);
    for(int i=0;i<mcount.size();++i)mcor<<rbin[i]<<"\t"<<mcount[i]<<"\t"<<count[i]<<endl;
    mcor.close();

    cout<<CYAN<<"Output in file "<<GREEN<<ov_name<<RESET<<endl;
    cout<<CYAN<<"Done"<<endl;

  }


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
  void PowerSpectrumF::compute_cross_power_spectrum_grid(bool dm, vector<real_prec>&X,vector<real_prec>&Y)
  {

    this->So.enter(__PRETTY_FUNCTION__);

    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);

    FftwFunctions c_Ff(this->params);
    s_parameters_box s_p_box;
    real_prec ngal_new=0;

    c_Ff.data_g.clear();
    c_Ff.data_g.shrink_to_fit();
    c_Ff.data_g.resize(this->params._NGRID(),0);

    if (this->params._input_type()=="delta_grid")
      {
#pragma omp parallel
        for(ULONG i=0;i<this->params._NGRID();++i)
          c_Ff.data_g[i]=static_cast<real_prec>(Y[i]);
        ngal_new=this->params._ngal_delta();
      }
    else if (this->params._input_type()=="density_grid")
      {
#pragma omp parallel for reduction(+:ngal_new)
	     for(ULONG i=0;i<this->params._NGRID();++i)
	       ngal_new+=static_cast<real_prec>(Y[i]);
    	real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
#pragma omp parallel for
    	for(ULONG i=0;i<this->params._NGRID();++i)
	       c_Ff.data_g[i]=(static_cast<real_prec>(Y[i])/static_cast<real_prec>(nmean))-1.;
  	  this->params.set_ngal_delta(ngal_new);
     }
    if(true==this->params._SN_correction())
      c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
    c_Ff.set_normal_power(pow(factor,-2));

    c_Ff.data_gp.clear();
    c_Ff.data_gp.shrink_to_fit();
    c_Ff.data_gp.resize(this->params._NGRID(),0);
    ngal_new=0;
    if (this->params._input_type_two()=="delta_grid")
#ifdef _USE_OMP_
#pragma omp parallel
#endif
      for(ULONG i=0;i<this->params._NGRID();++i)
	c_Ff.data_gp[i]=static_cast<real_prec>(X[i]);

    else if (this->params._input_type_two()=="density_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
	for(ULONG i=0;i<this->params._NGRID();++i)
	  ngal_new+=static_cast<real_prec>(X[i]);
	real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	for(ULONG i=0;i<this->params._NGRID();++i)
	  c_Ff.data_gp[i]=(static_cast<real_prec>(X[i])/static_cast<real_prec>(nmean))-1.;
      }

    c_Ff.shot_noise2=0;
    factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
    c_Ff.set_normal_power_two(pow(factor,-2));


    if(false==dm && true==this->params._SN_correction())
      c_Ff.shot_noise2=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

    c_Ff.resize_fftw_vectors();

    kvector_data.clear();
    kvector_data.shrink_to_fit();
    for(int i=0;i<this->params._d_Nnp_data();i++)
      kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));


    this->pk0.clear();
    this->pk0.shrink_to_fit();
    this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
    this->modes_g.clear();
    this->modes_g.resize(this->params._d_Nnp_data(),0); //Monopole
    c_Ff.cross_power_spectrum_fkp(&s_p_box, this->pk0,this->modes_g);

  }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::compute_cross_power_spectrum_grid(bool dm,string file_X, string file_Y)
  {
    this->So.enter(__PRETTY_FUNCTION__);

    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);
    FileOutput File;
    FftwFunctions c_Ff(this->params);
    s_parameters_box s_p_box;

    real_prec ngal_new=0;
    vector<float>X(this->params._NGRID(),0);
    File.read_array_t<float>(file_X, X);

    vector<real_prec>Y(this->params._NGRID(),0);
    File.read_array_t<PrecType_Y>(file_Y, Y);
    c_Ff.data_g.clear();
    c_Ff.data_g.shrink_to_fit();
    c_Ff.data_g.resize(this->params._NGRID(),0);

    if (this->params._input_type()=="delta_grid")
      {
#pragma omp parallel
        for(ULONG i=0;i<this->params._NGRID();++i)
          c_Ff.data_g[i]=static_cast<real_prec>(Y[i]);
        ngal_new=this->params._ngal_delta();
      }
    else if (this->params._input_type()=="density_grid")
      {
#pragma omp parallel for reduction(+:ngal_new)
	for(ULONG i=0;i<this->params._NGRID();++i)
	  ngal_new+=static_cast<real_prec>(Y[i]);
	real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#pragma omp parallel for
	for(ULONG i=0;i<this->params._NGRID();++i)
	  c_Ff.data_g[i]=(static_cast<real_prec>(Y[i])/static_cast<real_prec>(nmean))-1.;
	this->params.set_ngal_delta(ngal_new);
      }


    if(true==this->params._SN_correction())
      c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
    c_Ff.set_normal_power(pow(factor,-2));

    Y.clear(); Y.shrink_to_fit();



    c_Ff.data_gp.clear();
    c_Ff.data_gp.shrink_to_fit();
    c_Ff.data_gp.resize(this->params._NGRID(),0);
    ngal_new=0;

    for(ULONG i=0;i<this->params._NGRID();++i)
      c_Ff.data_gp[i]=static_cast<real_prec>(X[i]);


    if (this->params._input_type_two()=="delta_grid")
#ifdef _USE_OMP_
#pragma omp parallel
#endif
      for(ULONG i=0;i<this->params._NGRID();++i)
	c_Ff.data_gp[i]=static_cast<real_prec>(X[i]);

    else if (this->params._input_type()=="density_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
	for(ULONG i=0;i<this->params._NGRID();++i)
	  ngal_new+=static_cast<real_prec>(X[i]);
	real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	for(ULONG i=0;i<this->params._NGRID();++i)
	  c_Ff.data_gp[i]=(static_cast<real_prec>(X[i])/static_cast<real_prec>(nmean))-1.;
      }

    c_Ff.shot_noise2=0;
    factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
    c_Ff.set_normal_power_two(pow(factor,-2));

    X.clear(); X.shrink_to_fit();



    if(false==dm && true==this->params._SN_correction())
      c_Ff.shot_noise2=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);


    c_Ff.write_fftw_parameters();
    c_Ff.resize_fftw_vectors();



    kvector_data.clear();
    kvector_data.shrink_to_fit();
    for(int i=0;i<this->params._d_Nnp_data();i++)
      kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));

    this->pk0.clear();
    this->pk0.shrink_to_fit();
    this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
    this->modes_g.clear();
    this->modes_g.resize(this->params._d_Nnp_data(),0); //Monopole


    c_Ff.cross_power_spectrum_fkp(&s_p_box, this->pk0,this->modes_g);
    write_power_and_modes();
    cout<<"ebony"<<endl;
  }

  // *************************************************************************************
  // *************************************************************************************
  // *************************************************************************************
  // *************************************************************************************


  void PowerSpectrumF::compute_power_spectrum(bool verbose, bool mcut){

    time_t start;
    time (&start);

#ifdef _USE_OMP_
    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);
#endif

    if(true==this->params._weight_with_mass())
      {
	So.message_screen("***************************************************");
	So.message_screen("****Measuring the Mass weighted power spectrum****");
	So.message_screen("***************************************************");
      }

    string file_pow=this->file_power;
    int N_intervals=this->params._NMASSbins_power()+1;

#ifdef _USE_MASS_CUTS_PK_
    mcut=true;
#endif


#ifdef _USE_MASS_CUTS_PK_
    vector<real_prec>mass_cuts;
#elif defined _USE_MASS_BINS_PK_
    vector<real_prec>mass_bin_min;
    vector<real_prec>mass_bin_max;
#endif

    int im=0;
#ifdef _USE_MASS_CUTS_PK_

    if(true==mcut)
      {
	mass_cuts.resize(N_intervals,0);

#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
	mass_cuts[0]=pow(10,l_minp);
	mass_cuts[1]=PROP_THRESHOLD_MULTI_SCALE_1;
	mass_cuts[2]=PROP_THRESHOLD_MULTI_SCALE_2;
	mass_cuts[3]=PROP_THRESHOLD_MULTI_SCALE_3;
	mass_cuts[4]=PROP_THRESHOLD_MULTI_SCALE_4;
	So.message_warning("Mass-cuts are defined in ", __PRETTY_FUNCTION__);
#elif defined _USE_VMAX_AS_OBSERVABLE_POWER_
	cout<<mcut<<endl;
	So.message_warning("VMAX-cuts are defined in ", __PRETTY_FUNCTION__);
	real_prec l_minp=log10(this->params._VMAXmin());
	mass_cuts[0]=pow(10,l_minp);
	mass_cuts[1]=PROP_THRESHOLD_MULTI_SCALE_1;
	mass_cuts[2]=PROP_THRESHOLD_MULTI_SCALE_2;
	mass_cuts[3]=PROP_THRESHOLD_MULTI_SCALE_3;
	mass_cuts[4]=PROP_THRESHOLD_MULTI_SCALE_4;
#endif
      }
    else
      {
	real_prec mcut_aux=MINIMUM_PROP_CUT;
#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
	So.message_screen("Power spectrum mesasured with one mass-cut at" , mcut_aux, "Ms/h");
#elif defined _USE_VMAX_AS_OBSERVABLE_POWER_
	So.message_screen("Power spectrum mesasured with one VMAX cut at" , mcut_aux, "km/s");
#endif
	if(true==this->params._weight_with_mass())
	  {
	    So.message_screen("Mass weighted power spectrum");
	    mcut_aux=pow(10,this->params._LOGMASSmax());
	  }
	mass_cuts.push_back(mcut_aux);
      }

    for(int i=0;i<N_intervals;++i)
      cout<<"Cut "<<i<<"  :"<<mass_cuts[i]<<endl;


    for(im=0; im< N_intervals;++im)
      {


#elif defined (_USE_MASS_BINS_PK_)
	So.message_warning("Property-bins are defined in PowerSpectrumF::compute_power_spectrum");

	mass_bin_min.resize(N_intervals,0);
	mass_bin_max.resize(N_intervals,0);

#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
	real_prec l_minp=this->params._LOGMASSmin();
	real_prec l_maxp=this->params._LOGMASSmax();
#elif defined _USE_VMAX_AS_OBSERVABLE_POWER_
	//    real_prec l_minp=log10(this->params._VMAXmin());
	//    real_prec l_maxp=log10(this->params._VMAXmax());
	real_prec l_minp=log10(this->params._VMAXmin());
	real_prec l_maxp=log10(this->params._VMAXmax());

#elif defined _USE_RS_AS_OBSERVABLE_POWER_
	real_prec l_minp=log10(this->params._RSmin());
	real_prec l_maxp=log10(this->params._RSmax());
#elif defined _USE_SPIN_AS_OBSERVABLE_POWER_
	real_prec l_minp=log10(this->params._SPINmin());
	real_prec l_maxp=log10(this->params._SPINmax());
#endif

	mass_bin_min[0]=pow(10,l_minp);  // Let bin 0 be the full sample
	mass_bin_max[0]=pow(10,l_maxp);
	real_prec ldelta_prop=(l_maxp-l_minp)/static_cast<real_prec>(N_intervals-1);
  mass_bin_min[1]=pow(10,l_minp);
  mass_bin_max[1]=1e12;
  mass_bin_min[2]=1e12;
  mass_bin_max[2]=1e13;
  mass_bin_min[3]=1e13;
  mass_bin_max[3]=pow(10,l_maxp);

	/*
	  mass_bin_min[1]=pow(10,l_minp);
	  mass_bin_max[1]=(PROP_THRESHOLD_MULTI_SCALE_1);

	  mass_bin_min[2]=(PROP_THRESHOLD_MULTI_SCALE_1);
	  mass_bin_max[2]=(PROP_THRESHOLD_MULTI_SCALE_2);

	  mass_bin_min[3]=(PROP_THRESHOLD_MULTI_SCALE_2);
	  mass_bin_max[3]=(PROP_THRESHOLD_MULTI_SCALE_3);

	  mass_bin_min[4]=(PROP_THRESHOLD_MULTI_SCALE_3);
	  mass_bin_max[4]=(PROP_THRESHOLD_MULTI_SCALE_4);

	  mass_bin_min[4]=(PROP_THRESHOLD_MULTI_SCALE_4);
	  mass_bin_max[4]=pow(10,l_maxp);
	*/

	for(int i=0;i<N_intervals;++i)
	  cout<<"Bin "<<i<<"  :"<<mass_bin_min[i]<<"  "<<mass_bin_max[i]<<endl;


	for(im=0; im<N_intervals;++im)
	  {
#endif

	    FftwFunctions c_Ff(this->params);
	    c_Ff.set_imcut(im);

#ifdef _USE_MASS_CUTS_PK_
#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
	    this->file_power=file_pow+"_masscut"+to_string(im);
#elif defined (_USE_VMAX_AS_OBSERVABLE_POWER_)
	    this->file_power=file_pow+"_vmaxcut"+to_string(im);
#endif
#elif defined (_USE_MASS_BINS_PK_)

#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
	    this->file_power=file_pow+"_massbin"+to_string(im);
#elif defined (_USE_VMAX_AS_OBSERVABLE_POWER_)
	    this->file_power=file_pow+"_vmaxbin"+to_string(im);
#elif defined (_USE_RS_AS_OBSERVABLE_POWER_)
	    this->file_power=file_pow+"_rsbin"+to_string(im);
#elif defined (_USE_SPIN_AS_OBSERVABLE_POWER_)
	    this->file_power=file_pow+"_spinbin"+to_string(im);
#endif
#endif


	    if(true==verbose)
	      {
		if(this->params._statistics()=="Pk_fkp")So.welcome_message();
		if(this->params._statistics()=="Bk_fkp")So.welcome_message_bispectrum();
		if(this->params._statistics()=="Bk_fkp_fast")So.welcome_message_bispectrum_fast();
		if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")So.welcome_message_yama();
	      }


	    if(this->params._sys_of_coord_g()==2)
	      So.write_cosmo_parameters((void *)&this->params.s_cosmo_pars);
	    // ***********************************************************

	    // Define some structures here
	    s_parameters_box s_p_box;
	    s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
	    //
	    // ***********************************************************
	    // Add random and galaxy catalogues
	    this->c_Fm.input_type=this->params._input_type();

#if defined (_USE_MASS_CUTS_PK_) ||  defined (_USE_ALL_PK_)
	    if(this->params._input_type()!="catalog")
	      So.message_warning("Warning: expecting catalog to perform mass cuts when density field is provided");

	    real_prec mm=0;
	    if("catalog"==this->params._input_type())
#ifdef _USE_ALL_PK_
	      if(this->params._i_mass_g()>0)
		mm=pow(10,this->params._LOGMASSmin());
	      else
		mm=0;
#else
	    mm=mass_cuts[im];
#endif

	    if(this->params._input_type()=="catalog")
	      this->add_catalogues(mm);

#elif defined (_USE_MASS_BINS_PK_)
	    this->add_catalogues(mass_bin_min[im],mass_bin_max[im]);
#endif







	    if(this->params._input_type()=="catalog")
	      {


		// Tabulate r-z relation if radial coordinate is redshift
		vector<gsl_real>vzz(params._N_z_bins(),0);
		vector<gsl_real>vrc(params._N_z_bins(),0);
		So.message_screen("Computing comovong distances");
		if(this->params._sys_of_coord_g()==1 ||this->params._sys_of_coord_g()==2 )
		  c_Cf.Comoving_distance_tabulated(Z_MIN,Z_MAX, (void *)&this->params.s_cosmo_pars,vzz,vrc);
		So.DONE();
		// **************************************************************************
		// Derived parameters associated to
		//  c_Ff.set_healpix_pars(params._Healpix_resolution());

		// **************************************************************************
		// If applies, give a first estimate of mean number density from a box
		// in case we do not use random catalog                                                    *
		//If a random catalog is used, set this numer to 1
		//and use the nmbar tabulated in the catalogs or computed in this code
		mean_density=1.0;
		if(false==this->params._use_random_catalog())
		  {
		    So.message_screen("Using particles in a box.");
		    mean_density=static_cast<real_prec>(this->N_galaxy)/pow(this->params._Lbox(),3);
		    So.message_screen("Mean Number density = ",mean_density," (Mpc/h)^(-3)");
		  }


		// *************************************************************************
		// If nbar is not tabulated, compute it from the random catalog
		bool compute_dndz=false;
		if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
		  compute_dndz=true;

		// *************************************************************************
		// Give a first estimate of the alpha-parameter                                            *
		real_prec alpha_0=1.0;
		if(true==this->params._use_random_catalog())
		  alpha_0 = ((real_prec)this->N_galaxy)/((real_prec)this->N_random);


		// This structure will be used in 1P_this->params._statistics()
		s_dndz s_dndz_params;
		if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
		  s_dndz_params={
				 this->random_cat.Halo,
				 rc_n_columns,
				 alpha_0,
				 this->params._nbar_tabulated(),
				 compute_dndz,
				 this->params._constant_depth(),
				 vzz,
				 vrc,
				 this->params._N_dndz_bins(),
				 this->params._new_N_dndz_bins(),
				 this->params._redshift_min_sample(),
				 this->params._redshift_max_sample(),
				 this->params._area_survey(),
	  	   this->params._sys_of_coord_r(),
				 this->params._i_coord1_r(),
				 this->params._i_coord2_r(),
				 this->params._i_coord3_r(),
				 c_Ff.area_pixel,
				 c_Ff.npixels,
				 c_Ff.nside,
				 file_dndz
		  } ;



		// This should only be defined if we do not use randoms with nbar tabulated.
		// IN FFTWFUNCTIONS ALL CALLS TO HEALPIX AND MAP-DEFINED VECTORS ARE COMMENTED
		vector<gsl_real> z_v;
		vector<gsl_real> dndz_v;
		vector< vector<gsl_real> > dndz_matrix;
		// If nbar is not tabulated, Compute a smoothed version of dN/dz from randoms to get nbar  *
		if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
		  {
		    z_v.resize(params._new_N_dndz_bins(),0);
		    dndz_v.resize(z_v.size(),0);
		    dndz_matrix.resize(z_v.size());
		    for(int i=0;i<dndz_matrix.size(); ++i)dndz_matrix[i].resize(c_Ff.npixels,0);
		    c_Op.dndz((void *)&s_dndz_params,z_v, dndz_v, dndz_matrix);
		  }
		// *************************************************************************
		So.message_screen("Setting data in structure for TRACERS");
		s_data_structure s_data_struct_g={
		  this->tracer_cat.Halo,
		  gc_n_columns,
		  this->params._sys_of_coord_g(),
		  "data",
		  mean_density,
		  this->params._nbar_tabulated(),
		  compute_dndz,
		  z_v,
		  dndz_v,
		  dndz_matrix
		};
		So.DONE();
		So.message_screen("Freeing memmory prop in ", __PRETTY_FUNCTION__);
		this->tracer_cat.Halo.clear();
		this->tracer_cat.Halo.shrink_to_fit();
		So.DONE();

		// *************************************************************************
		// Allocate structure with random catalogue and information of dN/dz                       *
		// *************************************************************************
		So.message_screen("Setting data in structure for RANDOMS");
		s_data_structure s_data_struct_r={
			this->random_cat.Halo,
			rc_n_columns,
			this->params._sys_of_coord_r(),
			"random",
			mean_density,
			this->params._nbar_tabulated(),
			compute_dndz,
			z_v,
			dndz_v,
			dndz_matrix
		};
		So.DONE();
		So.message_screen("Freeing memmory prop in ", __PRETTY_FUNCTION__);
		this->random_cat.Halo.clear();
		this->random_cat.Halo.shrink_to_fit();
		So.DONE();

		// *****************************************************************************************
		// Allocate a strucuture

		s_p_box.npixels=c_Ff.npixels;
		s_p_box.nside=c_Ff.nside;
		s_p_box.file_dndz=file_dndz;


		// *****************************************************************************************
		// Transforming to cartessian coord.- and searching for box side lenght.
		if(this->params._sys_of_coord_g()!=0)
		  {
		    So.message_screen("Transform Coordinates in tracer catalogue to cartesian coordinates");
		    c_Ff.cart_coordinates(&s_p_box,&s_data_struct_g);
		    So.DONE();
		  }

		if(true==this->params._use_random_catalog())
		  {
		    if( this->params._sys_of_coord_r()!=0)
		      {
			       So.message_screen("Transform Coordinates in random catalogue to cartesian coordinates");
      			c_Ff.cart_coordinates(&s_p_box,&s_data_struct_r);
			       So.DONE();
		      }
		  }

		// *****************************************************************************************
		// Determine size of box for the density interpolation and the Fourier transform:
		// New version: we do this in the same loop that convert to cartesian coords.
		// We then save other loop over the galaxies!
		// The side of the box computed from the catalog is a public variable of FFTW Lside_data.
		// Given the fact that we might want to have it fixed from the parameter file
		// we select the new Lside and pass it again as Lside
		real_prec Lside=this->params._Lbox();
		if(true==params._new_Lbox())
    { 
  	  Lside=c_Ff._Lbox_data();
      this->params.set_Lbox(Lside);
    }
		// *****************************************************************************************
		c_Ff.resize_fftw_vectors();

		// **********************************************************************************
		// Estimate of the mean number density
		//  cout<<"Maximum Nfft allowed by mean density = "<<(int)(2.*pow(N_galaxy, 1./3.))<<endl;
		mean_density=this->N_galaxy/pow(Lside,3);  //This is  raw estimate!!
		if(false==this->params._use_random_catalog())
		  mean_density=this->N_galaxy/pow(Lside,3);
		else mean_density=1.0;

		if(true==verbose)
		  {
		    c_Ff.write_fftw_parameters();
		  }
		// ***********************************************************************************
		// Build interpolated galaxy density field
		if(this->params._statistics()=="Pk_y_ds")
		  {
		    So.message_screen("Creating galaxy density field on a Fourier grid...");
		    c_Ff.get_power_moments_fourier_grid_ds_yam(&s_data_struct_g);
		    So.DONE();
		  }
		else
		  {
		    So.message_screen("Interpolating galaxy density field on a grid");
#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
		    c_Ff.get_interpolated_density_field_old(&s_data_struct_g);
#else
		    c_Ff.get_interpolated_density_field(&s_data_struct_g);
#endif
		    So.DONE();
		  }
		// ***********************************************************************************
		// Build interpolated random density field
		if(true==this->params._use_random_catalog())
		  {
		    if(this->params._statistics()=="Pk_y_ds")
		      {
			So.message_screen("Creating random density field on a Fourier grid");
		        c_Ff.get_power_moments_fourier_grid_ds_yam(&s_data_struct_r);
			So.DONE();
		      }
		    else
		      {
			So.message_screen("Interpolating random density field on a grid");
#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
			c_Ff.get_interpolated_density_field_old(&s_data_struct_r);
#else
			c_Ff.get_interpolated_density_field(&s_data_struct_r);
#endif
			So.DONE();
		      }

		  }
		else
		  {
		    real_prec vol=pow(Lside,3);
		    c_Ff.raw_sampling(vol);
		  }

  		c_Ff.get_parameters_estimator(verbose);
	   	c_Ff.get_fluctuation();
    }
    else if (this->params._input_type()=="delta_grid" || this->params._input_type()=="density_grid"  ) // Else, we read the delta from this input file.
     {

		So.message_screen("Starting density field on a grid");

		real_prec ngal_new;
		bool measure_diff=false;

		if(false==this->params._measure_cross() && false==measure_diff) // If no crossed power, read per default theparams._delta_grid_file()
		  {
		    fftw_array<float> dummy(this->params._NGRID());

		    switch(this->params._measure_cross_from_1())
		      { //choose the file to get the auto power from
		      case(1):
	       		this->c_Fm.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
			    break;
		      case(2):
			       this->c_Fm.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
			    break;
		      case(3):
			      this->c_Fm.read_array(this->params._delta_grid_file3(), dummy,this->params._NGRID());
			    break;
		      case(4):
			       this->c_Fm.read_array(this->params._delta_grid_file4(), dummy,this->params._NGRID());
			    break;
		     }

		    c_Ff.data_g.clear();
		    c_Ff.data_g.shrink_to_fit();
		    c_Ff.data_g.resize(this->params._NGRID(),0);

		    if (this->params._input_type()=="delta_grid")
		      {
#ifdef _USE_OMP_
#pragma omp parallel
#endif
	 		  for(ULONG i=0;i<this->params._NGRID();++i)
    			  c_Ff.data_g[i]=static_cast<real_prec>(dummy[i]);
	 	   	ngal_new=this->params._ngal_delta();
      }
		    else if (this->params._input_type()=="density_grid")
		      {
			ngal_new=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)
			  ngal_new+=static_cast<real_prec>(dummy[i]);
			real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)
			  c_Ff.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean))-1.;
			this->params.set_ngal_delta(ngal_new);
			c_Ff.set_n_gal(ngal_new);
		      }

		    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
		    c_Ff.set_normal_power(pow(factor,-2));
		    c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
		    if(true==verbose)
		      {
			c_Ff.write_fftw_parameters();
#ifdef _FULL_VERBOSE_
			So.message_screen("Shot Noise =",c_Ff.shot_noise);
#endif
		      }
		    c_Ff.resize_fftw_vectors();
		  }

		else if(true==measure_diff)
		  {

		    fftw_array<float> dummy(this->params._NGRID());
		    fftw_array<float> dummy2(this->params._NGRID());

		    this->c_Fm.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
		    this->c_Fm.read_array(this->params._delta_grid_file2(), dummy2,this->params._NGRID());

		    c_Ff.data_g.resize(this->params._NGRID(),0);


		    ULONG ngal_new2=0;
		    ULONG ngal_new1=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new1)
#endif
		    for(ULONG i=0;i<this->params._NGRID();++i)
		      ngal_new1+=static_cast<real_prec>(dummy[i]);


#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new2)
#endif
		    for(ULONG i=0;i<this->params._NGRID();++i)
		      ngal_new2+=static_cast<real_prec>(dummy2[i]);


		    real_prec nmean1=static_cast<real_prec>(ngal_new1)/static_cast<real_prec>(this->params._NGRID());
		    real_prec nmean2=static_cast<real_prec>(ngal_new2)/static_cast<real_prec>(this->params._NGRID());



		    c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new1);

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
		    for(ULONG i=0;i<this->params._NGRID();++i)
		      //	    c_Ff.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean1) - static_cast<real_prec>(dummy2[i])/static_cast<real_prec>(nmean2));///c_Ff.shot_noise;
		      c_Ff.data_g[i]=(static_cast<real_prec>(dummy[i]) - static_cast<real_prec>(dummy2[i])/static_cast<real_prec>(nmean2));///c_Ff.shot_noise;

		    this->params.set_ngal_delta(ngal_new1);
		    c_Ff.set_n_gal(ngal_new1);


		    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
		    c_Ff.set_normal_power(pow(factor,-2));
		    c_Ff.shot_noise=0;
		    if(true==verbose)
		      c_Ff.write_fftw_parameters();
		    c_Ff.resize_fftw_vectors();
     }
		else  if(true==this->params._measure_cross()) // If no crossed power, read per default theparams._delta_grid_file()  // if we measure the cross, then
		  {
		    c_Ff.data_g.resize(this->params._NGRID(),0);
		    fftw_array<float> dummy(this->params._NGRID());
		    switch(this->params._measure_cross_from_1()){ //choose the file to get the auto power from
		    case(1):
		      this->c_Fm.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
		      break;
		    case(2):
		      this->c_Fm.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
		      break;
		    case(3):
		      this->c_Fm.read_array(this->params._delta_grid_file3(), dummy,this->params._NGRID());
		      break;
		    case(4):
		      this->c_Fm.read_array(this->params._delta_grid_file4(), dummy,this->params._NGRID());
		      break;
		    }

		    if (this->params._input_type()=="delta_grid")
		      {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)c_Ff.data_g[i]=static_cast<real_prec>(dummy[i]);
			ngal_new=this->params._ngal_delta();
		      }
		    else if (this->params._input_type()=="density_grid")
		      {
			ngal_new=0;
			for(ULONG i=0;i<this->params._NGRID();++i)ngal_new+=static_cast<real_prec>(dummy[i]);
			real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)
			  c_Ff.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean))-1.0;
		      }

		    c_Ff.shot_noise=0;
		    if(true==this->params._SN_correction())
		      c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
		    So.message_screen("Shot Noise =",c_Ff.shot_noise);

		    switch(this->params._measure_cross_from_2())
		      { //choose the file to get the auto power from
		      case(1):
			this->c_Fm.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
			break;
		      case(2):
			this->c_Fm.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
			break;
		      case(3):
			this->c_Fm.read_array(this->params._delta_grid_file3(), dummy, this->params._NGRID());
			break;
		      case(4):
			this->c_Fm.read_array(this->params._delta_grid_file4(), dummy, this->params._NGRID());
			break;
		      }

		    c_Ff.data_gp.resize(this->params._NGRID(),0);

		    if (this->params._input_type()=="delta_grid")
		      {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)
			  c_Ff.data_gp[i]=static_cast<real_prec>(dummy[i]);


			ngal_new=this->params._ngal_delta();
		      }
		    else if (this->params._input_type()=="density_grid")
		      {
			ngal_new=0;




			//                  for(ULONG i=0;i<this->params._NGRID();++i)c_Ff.data_gp[i]=static_cast<real_prec>(dummy[i]);

#ifdef _KONV_
			ULONG ntt=this->params._NGRID_h();
			FileOutput File;
			vector<real_prec>kernel(ntt,0);
			File.read_array("/net/vaina/scratch/balaguera/data/Numerics/IACmocks/ANALYSIS/BAM/Output_Minerva_R220_III/Bam_Kernel.dat",kernel);
			convolvek(this->params._Nft(),c_Ff.data_gp, kernel,c_Ff.data_gp);
#endif

			//                 for(ULONG i=0;i<this->params._NGRID();++i)
			//                    ngal_new+=c_Ff.data_gp[i];

			//                  real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
			//#pragma omp parallel for
			//                  for(ULONG i=0;i<this->params._NGRID();++i)
			//                    c_Ff.data_gp[i]=(static_cast<real_prec>(c_Ff.data_gp[i])/static_cast<real_prec>(nmean))-1.0;

			this->So.message_warning("In PowerSpectrumF.cpp I have manually set that the field2 is already a delta. This can be solved if I define a new variable input_type for the second field in the cross power");
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
			for(ULONG i=0;i<this->params._NGRID();++i)
			  c_Ff.data_gp[i]=static_cast<real_prec>(dummy[i]);


		      }


		    // Here we find 1+delta in the grid
		    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
		    c_Ff.set_normal_power(pow(factor, -2));

		    //IF IT IS DM
		    c_Ff.shot_noise2=0;//static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

		    if(true==this->params._SN_correction())
		      {
			So.message_screen("Shot noise 1 =", c_Ff.shot_noise);
			So.message_screen("Shot noise 2 =", c_Ff.shot_noise2);
		      }
		    else
		      So.message_screen("No SN correction");

		    if(true==verbose)
    			c_Ff.write_fftw_parameters();
		
        c_Ff.resize_fftw_vectors();
		  }
	   }


	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // *****************************************************************************************
	    // WELCOME TO FOURIER SPACE
	    // *****************************************************************************************
	    if(this->params._statistics()=="Pk_fkp" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc"   || this->params._statistics()=="Pk_ysc" ||  this->params._statistics()=="Pk_y_ds")
	      {

		// *****************************************************************************************
		// FFTW and estimates of power spectrum                                                    *
		// *****************************************************************************************
		kvector_data.clear();
		kvector_data.shrink_to_fit();
		kvector_window.clear();
		kvector_window.shrink_to_fit();
		if("linear" == this->params._type_of_binning())
		  {
		    for(int i=0;i<this->params._d_Nnp_data();i++)
		      kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));

		    for(int i=0;i<this->params._d_Nnp_window();i++)
		      kvector_window.push_back(this->params._d_kmin()+c_Ff.DeltaK_window*(i+0.5));
		  }
		else if("log"==this->params._type_of_binning())
		  {
		    for(int i=0;i<kvector_data.size();i++)
		      kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
		    for(int i=0;i<kvector_window.size();i++)
		      kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
		  }

		for(int i=0;i<this->params._d_Nnp_data();i++)
		  kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
		for(int i=0;i<params._N_mu_bins();i++)
		  muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));


		// *****************************************************************************
		// Resize arrays for P(k), and 2d P(k). Compute and write to file

		this->pk0.clear();
		this->pk0.shrink_to_fit();
		this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
		//#ifdef _WRITE_MULTIPOLES_
		this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
		this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
		//#endif
		this->pk_w.clear();
		this->pk_w.shrink_to_fit();
		this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

		this->modes_g.clear();
		this->modes_g.shrink_to_fit();
		this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

		//#ifdef _WRITE_2DPOWER_
		this->pkk.resize(this->params._d_Nnp_data());
		this->pmk.resize(params._N_mu_bins());
		for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
		for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
		//#endif

		this->sigma_fkp.clear();
		this->sigma_fkp.shrink_to_fit();
		this->sigma_fkp.resize(this->params._d_Nnp_data(),0);

		// ****************************************************************************
		// Get power spectrum and more

		if(this->params._statistics()=="Pk_fkp")
		  {
		    c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);

		    sigma_y_l2.resize(this->params._d_Nnp_data(),0);
		    sigma_y_l4.resize(this->params._d_Nnp_data(),0);
		    if(true==params._FKP_error_bars())
		      {
			So.message("Computing FKP error bars");
			c_Ff.get_fkp_error_bars(&s_data_struct_r, kvector_data, this->pk0, this->modes_g, this->sigma_fkp);
		      }
		  }
		else if(this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_y_ds" || this->params._statistics()=="Pk_ysc" )
		  c_Ff.get_power_spectrum_yamamoto(&s_p_box, this->pk0,this->pk2,this->pk4,this->modes_g);

		//MISSINGN ERROR BARS FROM YAMAMOTO HERE.

	      }

	    // Estimates of Bispectrum. Using the DFT already done for P(k)
	    else if(this->params._statistics()=="Bk_fkp")
	      {

		if(this->params._type_of_binning()=="linear")
		  for(int i=0;i<this->params._d_Nnp_data();i++)
		    kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning
		else
		  if(this->params._type_of_binning()=="log"){
		    for(int i=0;i<this->params._d_Nnp_data();i++)
		      kvector_data_b.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
		  }
		bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
		sn_bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
		modes_tri.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());

		c_Ff.get_bispectrum_fkp('d', &s_p_box, bispectrum, sn_bispectrum, modes_tri);
		c_Fm.write_to_file(file_bispectrum,kvector_data_b,bispectrum,modes_tri);
	      }

	    // Estimates of Bispectrum for FKP using fast version
	    else if(this->params._statistics()=="Bk_fkp_fast")
	      {
		//for(int i=0;i<c_Ff.Nshells_bk;i++)kvector_data_b.push_back(this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning

		this->pk0.resize(this->params._d_Nnp_data(),0);

		for(int i=0;i<c_Ff.Nshells_bk;i++)
		  kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Jennifer's binning

		bispectrum.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);
		sn_bispectrum.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);
		modes_tri.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);

		c_Ff.get_power_spectrum_for_bispectrum(&s_p_box, this->pk0);
		c_Ff.get_bispectrum_fkp_fast(&s_p_box,this->pk0,bispectrum,modes_tri,file_bispectrum);

	      }

#ifndef _WRITE_MULTIPOLES_
	    write_power_and_modes();
#else
	    write_power_spectrum();
#endif


#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_MASS_BINS_PK_)
	  }
#endif

      }






// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

    // Used specifically in case we supply grids 1+delta1 and 1+delta2 and we want to compute the auto and cross power
    // threof
    void PowerSpectrumF::compute_power_spectrum_grid(const vector<real_prec> &data_in)
    {
      this->So.enter(__PRETTY_FUNCTION__);

#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif

      FftwFunctions c_Ff(this->params);

      s_parameters_box s_p_box;
      c_Ff.write_fftw_parameters();
      c_Ff.resize_fftw_vectors();

      real_prec ngal_new,nmean;
      real_prec vol = static_cast<real_prec>(pow(this->params._Lbox(),3));

      // if delta  = rho - mean, (with Ngal given from par file) use normal=Ngal/Vol (i.e, constructing delta from a catalog)
      // if delta = rho/mean -1, use normal = Ncells/Vol (i.e, givng delta from outside.

      if(this->params._input_type()=="density_grid")
	{
	  ngal_new=get_nobjects(data_in);
	 this->params.set_ngal_delta(ngal_new);
	  c_Ff.set_n_gal(ngal_new);
	  nmean=static_cast<double>(ngal_new)/static_cast<double>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	  for(ULONG i=0;i<this->params._NGRID();++i)
	    c_Ff.data_g[i]=static_cast<real_prec>(data_in[i])-static_cast<real_prec>(nmean);
	  c_Ff.set_normal_power(static_cast<double>((static_cast<double>(ngal_new)/static_cast<double>(vol))*static_cast<double>(ngal_new)));
	}
      else if(this->params._input_type()=="delta_grid")
	{
	  ngal_new=1.0;
	 this->params.set_ngal_delta(ngal_new);
	  c_Ff.set_n_gal(ngal_new);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	  for(ULONG i=0;i<this->params._NGRID();++i)
	    c_Ff.data_g[i]=data_in[i];
	  c_Ff.set_normal_power(static_cast<real_prec>(this->params._NGRID())*static_cast<real_prec>(this->params._NGRID())/static_cast<real_prec>(vol));
	}

#ifdef _FULL_VERBOSE_
      if(ngal_new>1)
	So.message_screen("Number of tracers in input density field = ",ngal_new);
      So.message_screen("Normalization of power = ",c_Ff._normal_power());
#endif
      c_Ff.shot_noise=vol/static_cast<real_prec>(ngal_new);
      this->shot_noise=c_Ff.shot_noise;
#ifdef _FULL_VERBOSE_
      if(true==this->params._SN_correction())
	So.message_screen("Poisson Shot noise = ",c_Ff.shot_noise);
      else
	So.message_screen("Poisson Shot noise (not applied) = ",c_Ff.shot_noise);
#endif

      kvector_data.resize(this->params._d_Nnp_data(), 0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
      for(int i=0;i<this->params._d_Nnp_data();i++)
	this->kvector_data[i]=this->params._d_kmin()+(i+0.5)*this->params._d_DeltaK_data();

      this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
      this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
      c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->modes_g);

    }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

    // This method has as input the tracer catalog to measure the power once it has read before and outside the class
    // This is meant for the case in which NO RANDOMS ARE USED AND IS NOT READY TO USE MASS CUTS

    // tHIS ALSO IS MEANT FO RTHE OPTION catalog
void PowerSpectrumF::compute_power_spectrum(bool verbose, vector<s_Halo>& tracer_cat){

      time_t start;
      time (&start);

#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif


#ifdef _MASS_WEIGHT_POWER_
      if(true==this->params._weight_with_mass())
	So.message_screen("Measuring the Mass-power spectrum");
#elif defined(_USE_MASS_CUTS_PK_)
      So.message_screen("Measuring power spectrum in mass cuts");
#endif

      string file_pow=this->file_power;


#ifdef _USE_MASS_CUTS_PK_
      vector<real_prec>mass_cuts;

#ifdef _SET_GLOBAL_MASS_CUT_
#ifdef _USE_VMAX_AS_OBSERVABLE_
      So.message_screen("Using one global Vmax-cut at Vmax = ",MINIMUM_PROP_CUT," km/s");
#elif defined _USE_MASS_AS_OBSERVABLE_
      So.message_screen("Using one global Halo Mass-cut at M = ",MINIMUM_PROP_CUT, "Ms/h");
#endif


#else
      So.message_warning("Masss-cuts are defined in PowerSpectrumF::compute_power_spectrum");
#endif
      mass_cuts.clear();


      bool mcut=true;

      if(true==this->params._weight_with_mass())
	mcut=false;

      if(true==mcut)
	{
#ifdef _SET_GLOBAL_MASS_CUT_
	  mass_cuts.push_back(MINIMUM_PROP_CUT);
#else
	  mass_cuts.push_back(9e11);
	  mass_cuts.push_back(3e12);
	  mass_cuts.push_back(6e12);
	  mass_cuts.push_back(1e13);
	  mass_cuts.push_back(3e13);
	  mass_cuts.push_back(6e13);
#endif
	}
      else
	{
	  mass_cuts.push_back(pow(10,this->params._LOGMASSmin()*this->params._MASS_units()));
	}


      for(int im=0; im< mass_cuts.size();++im)
	{
#endif

	  FftwFunctions c_Ff(this->params);

#ifdef _USE_MASS_CUTS_PK_
	  c_Ff.set_imcut(im);
	  this->file_power=file_pow+"_masscut"+to_string(im);
#ifdef _SET_GLOBAL_MASS_CUT_
	  this->file_power=file_pow+"_global_cut";
#endif

#endif



	  if(true==verbose)
	    {
	      if(this->params._statistics()=="Pk_fkp")So.welcome_message();
	      if(this->params._statistics()=="Bk_fkp")So.welcome_message_bispectrum();
	      if(this->params._statistics()=="Bk_fkp_fast")So.welcome_message_bispectrum_fast();
	      if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")So.welcome_message_yama();
	    }


	  if( this->params._sys_of_coord_g()==2)
	    So.write_cosmo_parameters((void *)&this->params.s_cosmo_pars);

	  // Define some structures here
	  s_parameters_box s_p_box;
	  s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
	  //


	  // ***********************************************************
	  // Add random and galaxy catalogues
	  this->c_Fm.input_type=this->params._input_type();
	  this->N_galaxy=tracer_cat.size();

	  // ***********************************************************
	  // Tabulate r-z relation if radial coordinate is redshift
	  vector<gsl_real>vzz;
	  vector<gsl_real>vrc;
	  if( this->params._sys_of_coord_g()==1 || this->params._sys_of_coord_g()==2 )
	    {
	      vzz.resize(params._N_z_bins(),0);
	      vrc.resize(params._N_z_bins(),0);
	      c_Cf.Comoving_distance_tabulated(0,1.0, (void *)&this->params.s_cosmo_pars,vzz,vrc);
	    }

	  // **************************************************************************
	  // Derived parameters associated to
	  //  c_Ff.set_healpix_pars(params._Healpix_resolution());

	  // **************************************************************************
	  // If applies, give a first estimate of mean number density from a box
	  // in case we do not use random catalog                                                    *
	  //If a random catalog is used, set this numer to 1
	  //and use the nmbar tabulated in the catalogs or computed in this code
	  mean_density=1.0;

	  if(false==this->params._use_random_catalog())
	    {
	      if(true==verbose)
		So.message_screen("Using particles in a box.");

	      mean_density=static_cast<real_prec>(this->N_galaxy)/pow(this->params._Lbox(),3);
	      if(true==verbose)
		So.message_screen("Mean Number density = ",mean_density," (Mpc/h)^(-3)");
	    }


	  // *************************************************************************
	  // If nbar is not tabulated, compute it from the random catalog
	  bool compute_dndz=false;
	  if(true==this->params._use_random_catalog() && false== this->params._nbar_tabulated())
	    compute_dndz=true;

	  // *************************************************************************
	  // Give a first estimate of the alpha-parameter                                            *
	  real_prec alpha_0=1.0;
	  if(true==this->params._use_random_catalog())
	    alpha_0 = ((real_prec)this->N_galaxy)/((real_prec)this->N_random);


	  // This structure will be used in 1P_this->params._statistics()
	  s_dndz s_dndz_params;
	  if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
    s_dndz_params={
			   this->random_cat.Halo,
			   this->rc_n_columns,
			   alpha_0,
			   params._nbar_tabulated(),
			   compute_dndz,
			   params._constant_depth(),
			   vzz,
			   vrc,
			   params._N_dndz_bins(),
			   params._new_N_dndz_bins(),
			   this->params._redshift_min_sample(),
   		   this->params._redshift_max_sample(),
			   this->params._area_survey(),
			   this->params._sys_of_coord_r(),
			   this->params._i_coord1_r(),
			   this->params._i_coord2_r(),
			   this->params._i_coord3_r(),
			   c_Ff.area_pixel,
			   c_Ff.npixels,
			   c_Ff.nside,
			   file_dndz
	    };


	  // This should only be defined if we do not use randoms with nbar tabulated.
	  // IN FFTWFUNCTIONS ALL CALLS TO HEALPIX AND MAP-DEFINED VECTORS ARE COMMENTED
	  vector<gsl_real> z_v;
	  vector<gsl_real> dndz_v;
	  vector< vector<gsl_real> > dndz_matrix;
	  // If nbar is not tabulated, Compute a smoothed version of dN/dz from randoms to get nbar  *
	  if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
	    {
	      z_v.resize(this->params._new_N_dndz_bins(),0);
	      dndz_v.resize(z_v.size(),0);
	      dndz_matrix.resize(z_v.size());
	      for(int i=0;i<dndz_matrix.size(); ++i)dndz_matrix[i].resize(c_Ff.npixels,0);
	      c_Op.dndz((void *)&s_dndz_params,z_v, dndz_v, dndz_matrix);
	    }
	  // *************************************************************************

	  s_data_structure s_data_struct_g={
					    this->tracer_cat.Halo,
					    gc_n_columns,
					     this->params._sys_of_coord_g(),
					    "data",
					    mean_density,
					    params._nbar_tabulated(),
					    compute_dndz,
					    z_v,
					    dndz_v,
					    dndz_matrix
	  };


	  // *****************************************************************************************
	  // Allocate a strucuture
	  // to be passed to the class member functions. We pass only those parameters
	  // that were not passed through the set_pars method.

	  s_p_box={
		   vzz,
		   vrc,
		   c_Ff.npixels,
		   c_Ff.nside,
		   file_dndz,
	  };


	  // *****************************************************************************************
	  // Transforming to cartessian coord.- and searching for box side lenght.
	  if(this->params._sys_of_coord_g()!=0)
	    {
	      So.message_screen("Transform to cartesian coordinates in tracer catalogue");
	      c_Ff.cart_coordinates(&s_p_box,&s_data_struct_g);
	      So.DONE();
	    }
	  s_data_struct_g.properties=tracer_cat;

	  // *****************************************************************************************
	  // Determine size of box for the density interpolation and the Fourier transform:
	  // New version: we do this in the same loop that convert to cartesian coords.
	  // We then save other loop over the galaxies!
	  // The side of the box computed from the catalog is a public variable of FFTW Lside_data.
	  // Given the fact that we might want to have it fixed from the parameter file
	  // we select the new Lside and pass it again as Lside
	  real_prec Lside=this->params._Lbox();
	  if(this->params._new_Lbox())
	   this->params.set_Lbox(c_Ff._Lbox_data());
	  c_Ff.resize_fftw_vectors();
	  // **********************************************************************************
	  // Estimate of the mean number density
	  //  cout<<"Maximum Nfft allowed by mean density = "<<(int)(2.*pow(N_galaxy, 1./3.))<<endl;
	  mean_density=this->N_galaxy/pow(Lside,3);  //This is  raw estimate!!
	  if(false==this->params._use_random_catalog())
	    mean_density=this->N_galaxy/pow(Lside,3);  else mean_density=1.0;

	  if(true==verbose)
	      c_Ff.write_fftw_parameters();
	  // ***********************************************************************************
	  // Build interpolated galaxy density field
	  if(this->params._statistics()=="Pk_y_ds")
	    {
#ifdef _FULL_VERBOSE_
	      So.message_screen("Creating galaxy density field on a Fourier grid...");
#endif
	      c_Ff.get_power_moments_fourier_grid_ds_yam(&s_data_struct_g);
	      So.DONE();
	    }
	  else
	    {
#ifdef _FULL_VERBOSE_
	      So.message_screen("Interpolating galaxy density field on a grid");
#endif

#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
	      c_Ff.get_interpolated_density_field_old(&s_data_struct_g);
#else
	      c_Ff.get_interpolated_density_field(&s_data_struct_g);
#endif

#ifdef _FULL_VERBOSE_
	      So.DONE();
#endif
	    }
	  // ***********************************************************************************
	  // Build interpolated random density field
	  real_prec vol=pow(Lside,3);
	  c_Ff.raw_sampling(vol);

	  // **********************************************************************************
	  c_Ff.get_parameters_estimator( verbose);
	  // **********************************************************************************
	  // Build fluctuation                                                                       *
	  c_Ff.get_fluctuation();

	  // *****************************************************************************************
	  // *****************************************************************************************
	  // *****************************************************************************************
	  // *****************************************************************************************
	  // *****************************************************************************************
	  // *****************************************************************************************
	  // WELCOME TO FOURIER SPACE
	  // *****************************************************************************************
	  if(this->params._statistics()=="Pk_fkp" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc"   || this->params._statistics()=="Pk_ysc" ||  this->params._statistics()=="Pk_y_ds")
	    {

	      // *****************************************************************************************
	      // FFTW and estimates of power spectrum                                                    *
	      // *****************************************************************************************

	      kvector_data.clear();
	      kvector_data.shrink_to_fit();
	      kvector_window.clear();
	      kvector_window.shrink_to_fit();

	      if(this->params._type_of_binning()=="linear")
      		{
		       for(int i=0;i<this->params._d_Nnp_data();i++)
		        kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
    		  for(int i=0;i<this->params._d_Nnp_window();i++)
		        kvector_window.push_back(this->params._d_kmin()+c_Ff.DeltaK_window*(i+0.5));
		      }
	      else  if(this->params._type_of_binning()=="log")
		      {
		        for(int i=0;i<kvector_data.size();i++)
		          kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
      		  for(int i=0;i<kvector_window.size();i++)
		        kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
		     }
	      for(int i=0;i<this->params._d_Nnp_data();i++)
		      kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
	      for(int i=0;i<params._N_mu_bins();i++)
		      muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

	      // *****************************************************************************
	      // Resize arrays for P(k), and 2d P(k). Compute and write to file
	      this->pk0.clear();
	      this->pk0.shrink_to_fit();
	      this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
	      //#ifdef _WRITE_MULTIPOLES_
	      this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
	      this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
	      //#endif
	      this->pk_w.clear();
	      this->pk_w.shrink_to_fit();
	      this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

	      this->modes_g.clear();
	      this->modes_g.shrink_to_fit();
	      this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

	      //#ifdef _WRITE_2DPOWER_
	      this->pkk.resize(this->params._d_Nnp_data());
	      this->pmk.resize(params._N_mu_bins());
	      for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
	      for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
	      //#endif

	      this->sigma_fkp.clear();
	      this->sigma_fkp.shrink_to_fit();
	      this->sigma_fkp.resize(this->params._d_Nnp_data(),0);

	      // ****************************************************************************
	      // Get power spectrum and more

	      if(this->params._statistics()=="Pk_fkp")
		{
		  c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
		  sigma_y_l2.resize(this->params._d_Nnp_data(),0);
		  sigma_y_l4.resize(this->params._d_Nnp_data(),0);
		  if(true==params._FKP_error_bars())
		    {
		      So.message("Computing FKP error bars");
		      c_Ff.get_fkp_error_bars(&s_data_struct_r, kvector_data, this->pk0, this->modes_g, this->sigma_fkp);
		    }
		}
	      else if(this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_y_ds" || this->params._statistics()=="Pk_ysc" )
		{
		  c_Ff.get_power_spectrum_yamamoto(&s_p_box, this->pk0,this->pk2,this->pk4,this->modes_g);
		}
	      //MISSINGN ERROR BARS FROM YAMAMOTO HERE.

	    }

	  // Estimates of Bispectrum. Using the DFT already done for P(k)
	  else if(this->params._statistics()=="Bk_fkp")
	    {

	      if(this->params._type_of_binning()=="linear")
		for(int i=0;i<this->params._d_Nnp_data();i++)
		  kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning
	      else
		if(this->params._type_of_binning()=="log"){
		  for(int i=0;i<this->params._d_Nnp_data();i++)
		    kvector_data_b.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
		}
	      bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
	      sn_bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
	      modes_tri.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());

	      c_Ff.get_bispectrum_fkp('d', &s_p_box, bispectrum, sn_bispectrum, modes_tri);
	      c_Fm.write_to_file(file_bispectrum,kvector_data_b,bispectrum,modes_tri);
	    }

	  // Estimates of Bispectrum for FKP using fast version
	  else if(this->params._statistics()=="Bk_fkp_fast")
	    {
	      //for(int i=0;i<c_Ff.Nshells_bk;i++)kvector_data_b.push_back(this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning

	      this->pk0.resize(this->params._d_Nnp_data(),0);

	      for(int i=0;i<c_Ff.Nshells_bk;i++)
		kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Jennifer's binning

	      bispectrum.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);
	      sn_bispectrum.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);
	      modes_tri.resize(c_Ff.Nshells_bk*c_Ff.Nshells_bk*c_Ff.Nshells_bk,0);
	      c_Ff.get_power_spectrum_for_bispectrum(&s_p_box, this->pk0);
	      c_Ff.get_bispectrum_fkp_fast(&s_p_box,this->pk0,bispectrum,modes_tri,file_bispectrum);

	    }

	  So.DONE();

#ifndef _WRITE_MULTIPOLES_
	  write_power_and_modes();
#else
	  write_power_spectrum();
#endif

#ifdef _USE_MASS_CUTS_PK_
	}
#endif


    }






// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

    // This function is copied from the compute_power_spectrum_bam_real_space
    // and its meant to do the same, this time using explicit functions in redshift space.

void PowerSpectrumF::compute_power_spectrum_bam_redshift_space(vector<s_Halo>& tracer_cat){
      this->So.enter(__PRETTY_FUNCTION__);
      time_t start;
      time (&start);
#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif
    string file_pow=this->file_power_redshift_space;
    int N_intervals=this->params._NMASSbins_power()+1;
    vector<real_prec>mass_bin_min;
    vector<real_prec>mass_bin_max;
    mass_bin_min.resize(N_intervals,0);
    mass_bin_max.resize(N_intervals,0);
#ifdef _FULL_VERBOSE_
    So.message_warning("Mass-bins are defined in ", __PRETTY_FUNCTION__);
#endif
    real_prec l_minp=this->params._LOGMASSmin();
    real_prec l_maxp=this->params._LOGMASSmax();
    mass_bin_min[0]=pow(10,l_minp);  // Let bin 0 be the full sample
    mass_bin_max[0]=pow(10,l_maxp);
    mass_bin_min[1]=pow(10,l_minp);
    mass_bin_max[1]=1e12;
    mass_bin_min[2]=1e12;
    mass_bin_max[2]=1e13;
    mass_bin_min[3]=1e13;
    mass_bin_max[3]=pow(10,l_maxp);

    for(int im=0; im< N_intervals;++im)
    	{
	      FftwFunctions c_Ff(this->params);
        c_Ff.set_imcut(im);
        this->file_power=file_pow+"_massbin"+to_string(im);
        s_parameters_box s_p_box; 
     	  s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
		    this->c_Fm.input_type=this->params._input_type();
    	  real_prec alpha_0=1.0;
        ULONG in_new=0;
        vector<s_Halo> final_cat;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
            in_new++;
        final_cat.resize(in_new);
        in_new=0;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
           {
            final_cat[in_new].mass=tracer_cat[i].mass;
            final_cat[in_new].coord1=tracer_cat[i].coord1;
            final_cat[in_new].coord2=tracer_cat[i].coord2;
            final_cat[in_new].coord3=tracer_cat[i].coord3;
            final_cat[in_new].vel1=tracer_cat[i].vel1;
            final_cat[in_new].vel2=tracer_cat[i].vel2;
            final_cat[in_new].vel3=tracer_cat[i].vel3;
            in_new++;
          }

#ifdef _FULL_VERBOSE_
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_min[im]);
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_max[im]);
        So.message_screen("Number of tracers selected = ",in_new);
#endif
        this->N_galaxy=in_new;
        real_prec mean_density=static_cast<real_prec>(in_new)/pow(this->params._Lbox(),3);
        s_data_structure s_data_struct_g;
        s_data_struct_g.properties=final_cat;
        s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
        s_data_struct_g.mean_density=mean_density;
        s_data_struct_g.catalog="data";
        final_cat.clear();final_cat.shrink_to_fit();

        c_Ff.set_n_gal(in_new);
        s_p_box.npixels=c_Ff.npixels;
        s_p_box.nside=c_Ff.nside;
        s_p_box.file_dndz=file_dndz;

        this->params.set_use_random_catalog(false);
    	  c_Ff.resize_fftw_vectors();
 #ifdef _FULL_VERBOSE_
        c_Ff.write_fftw_parameters();
    	  So.message_screen("Interpolating galaxy density field on a grid");
#endif
        c_Ff.get_interpolated_density_field(&s_data_struct_g);

  	    real_prec vol=pow(this->params._Lbox(),3);
	      c_Ff.raw_sampling(vol);
        this->params.set_use_random_catalog(false);
    	  c_Ff.get_parameters_estimator(true);
    	  c_Ff.get_fluctuation();

  	  // *****************************************************************************************
	      // *****************************************************************************************
	      kvector_data.clear();
	      kvector_data.shrink_to_fit();
	      kvector_window.clear();
	      kvector_window.shrink_to_fit();
	      if(this->params._type_of_binning()=="linear")
    		{
		      for(int i=0;i<this->params._d_Nnp_data();i++)
		        kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
    		  for(int i=0;i<this->params._d_Nnp_window();i++)
	    	    kvector_window.push_back(this->params._d_kmin()+this->params._d_DeltaK_window()*(i+0.5));
		    }
	      else  if(this->params._type_of_binning()=="log")
	     	{
		      for(int i=0;i<kvector_data.size();i++)
		        kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
    		  for(int i=0;i<kvector_window.size();i++)
		        kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
    		}
	      for(int i=0;i<this->params._d_Nnp_data();i++)
		      kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
	      for(int i=0;i<params._N_mu_bins();i++)
		      muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

	      // *****************************************************************************
	      // Resize arrays for P(k), and 2d P(k). Compute and write to file

	      this->pk0.clear();
	      this->pk0.shrink_to_fit();
	      this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
	      //#ifdef _WRITE_MULTIPOLES_
	      this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
	      this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
	      //#endif
	      this->pk_w.clear();
	      this->pk_w.shrink_to_fit();
	      this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

	      this->modes_g.clear();
	      this->modes_g.shrink_to_fit();
	      this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

	      this->pkk.resize(this->params._d_Nnp_data());
	      this->pmk.resize(params._N_mu_bins());
#ifdef _WRITE_2DPOWER_
	      for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
	      for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
#endif
        c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
        So.DONE();
#ifndef _WRITE_MULTIPOLES_
    	  this->write_power_and_modes();
#else
	      this->write_power_spectrum(false);
#endif

	}
}
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

    // This method has as input the tracer catalog to measure the power once it has read before and outside the class
    // This is meant for the case in which NO RANDOMS ARE USED AND IS NOT READY TO USE MASS CUTS

    // tHIS ALSO IS MEANT FO RTHE OPTION catalog

void PowerSpectrumF::compute_power_spectrum_bam_real_space(vector<s_Halo>& tracer_cat){
      this->So.enter(__PRETTY_FUNCTION__);
      time_t start;
      time (&start);
#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif
    string file_pow=this->file_power_real_space;
    int N_intervals=this->params._NMASSbins_power()+1;
    vector<real_prec>mass_bin_min;
    vector<real_prec>mass_bin_max;
    mass_bin_min.resize(N_intervals,0);
    mass_bin_max.resize(N_intervals,0);
#ifdef _FULL_VERBOSE_
    So.message_warning("Mass-bins are defined in ", __PRETTY_FUNCTION__);
#endif
    real_prec l_minp=this->params._LOGMASSmin();
    real_prec l_maxp=this->params._LOGMASSmax();
    mass_bin_min[0]=pow(10,l_minp);  // Let bin 0 be the full sample
    mass_bin_max[0]=pow(10,l_maxp);
    mass_bin_min[1]=pow(10,l_minp);
    mass_bin_max[1]=1e12;
    mass_bin_min[2]=1e12;
    mass_bin_max[2]=1e13;
    mass_bin_min[3]=1e13;
    mass_bin_max[3]=pow(10,l_maxp);
    real_prec ldelta_prop=(l_maxp-l_minp)/static_cast<real_prec>(N_intervals-1);
    for(int im=0; im< N_intervals;++im)
      {
        FftwFunctions c_Ff(this->params);
        c_Ff.set_imcut(im);
        this->file_power=file_pow+"_massbin"+to_string(im);
        s_parameters_box s_p_box; 
        s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
        this->c_Fm.input_type=this->params._input_type();
        real_prec alpha_0=1.0;
        ULONG in_new=0;
        vector<s_Halo> final_cat;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
            in_new++;
        final_cat.resize(in_new);
        in_new=0;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
           {
            final_cat[in_new].mass=tracer_cat[i].mass;
            final_cat[in_new].coord1=tracer_cat[i].coord1;
            final_cat[in_new].coord2=tracer_cat[i].coord2;
            final_cat[in_new].coord3=tracer_cat[i].coord3;
            final_cat[in_new].vel1=tracer_cat[i].vel1;
            final_cat[in_new].vel2=tracer_cat[i].vel2;
            final_cat[in_new].vel3=tracer_cat[i].vel3;
            in_new++;
          }

#ifdef _FULL_VERBOSE_
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_min[im]);
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_max[im]);
        So.message_screen("Number of tracers selected = ",in_new);
#endif
        this->N_galaxy=in_new;
        real_prec mean_density=static_cast<real_prec>(in_new)/pow(this->params._Lbox(),3);
        s_data_structure s_data_struct_g;
        s_data_struct_g.properties=final_cat;
        s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
        s_data_struct_g.mean_density=mean_density;
        s_data_struct_g.catalog="data";
        final_cat.clear();final_cat.shrink_to_fit();

        c_Ff.set_n_gal(in_new);
        s_p_box.npixels=c_Ff.npixels;
        s_p_box.nside=c_Ff.nside;
        s_p_box.file_dndz=file_dndz;

        c_Ff.resize_fftw_vectors();
#ifdef _FULL_VERBOSE_
        c_Ff.write_fftw_parameters();
        So.message_screen("Interpolating galaxy density field on a grid");
#endif

        c_Ff.get_interpolated_density_field_real_space(&s_data_struct_g);
        real_prec vol=pow(this->params._Lbox(),3);
        c_Ff.raw_sampling(vol);
        c_Ff.get_parameters_estimator(true);
        c_Ff.get_fluctuation();

      // *****************************************************************************************
        // *****************************************************************************************
        kvector_data.clear();
        kvector_data.shrink_to_fit();
        kvector_window.clear();
        kvector_window.shrink_to_fit();
        if(this->params._type_of_binning()=="linear")
        {
          for(int i=0;i<this->params._d_Nnp_data();i++)
            kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
          for(int i=0;i<this->params._d_Nnp_window();i++)
            kvector_window.push_back(this->params._d_kmin()+this->params._d_DeltaK_window()*(i+0.5));
        }
        else  if(this->params._type_of_binning()=="log")
        {
          for(int i=0;i<kvector_data.size();i++)
            kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
          for(int i=0;i<kvector_window.size();i++)
            kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
        }
        for(int i=0;i<this->params._d_Nnp_data();i++)
          kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
        for(int i=0;i<params._N_mu_bins();i++)
          muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

        // *****************************************************************************
        // Resize arrays for P(k), and 2d P(k). Compute and write to file

        this->pk0.clear();
        this->pk0.shrink_to_fit();
        this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
        this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
        this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
        this->pk_w.clear();
        this->pk_w.shrink_to_fit();
        this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

        this->modes_g.clear();
        this->modes_g.shrink_to_fit();
        this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

        this->pkk.resize(this->params._d_Nnp_data());
        this->pmk.resize(params._N_mu_bins());
#ifdef _WRITE_2DPOWER_
        for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
        for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
#endif
       c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
       So.DONE();
#ifndef _WRITE_MULTIPOLES_
        this->write_power_and_modes();
#else
        this->write_power_spectrum(false); // argument asks to write sigma or not
#endif

  }


}

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

// This tries to unify the functions compute_power_spectrum_bam_real_space and compute_power_spectrum_bam_redshift_space. Not yet tested
void PowerSpectrumF::compute_power_spectrum_bam(vector<s_Halo>& tracer_cat, string space_p){
      this->So.enter(__PRETTY_FUNCTION__);
      time_t start;
      time (&start);
#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif

    string file_pow;  
    if(space_p=="real")
      file_pow=this->file_power_real_space;
    else if (space_p=="redshift")
      file_pow=this->file_power_redshift_space;

    int N_intervals=this->params._NMASSbins_power()+1;
    vector<real_prec>mass_bin_min;
    vector<real_prec>mass_bin_max;
    mass_bin_min.resize(N_intervals,0);
    mass_bin_max.resize(N_intervals,0);
#ifdef _FULL_VERBOSE_
    So.message_warning("Mass-bins are defined in ", __PRETTY_FUNCTION__);
#endif
    real_prec l_minp=this->params._LOGMASSmin();
    real_prec l_maxp=this->params._LOGMASSmax();
    mass_bin_min[0]=pow(10,l_minp);  // Let bin 0 be the full sample
    mass_bin_max[0]=pow(10,l_maxp);
    real_prec ldelta_prop=(l_maxp-l_minp)/static_cast<real_prec>(N_intervals-1);
    mass_bin_min[1]=pow(10,l_minp);
    mass_bin_max[1]=1e12;
    mass_bin_min[2]=1e12;
    mass_bin_max[2]=1e13;
    mass_bin_min[3]=1e13;
    mass_bin_max[3]=pow(10,l_maxp);
    for(int im=0; im< N_intervals;++im)
      {
        FftwFunctions c_Ff(this->params);
        c_Ff.set_imcut(im);
        this->file_power=file_pow+"_massbin"+to_string(im);
        s_parameters_box s_p_box; 
        s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
        this->c_Fm.input_type=this->params._input_type();
        real_prec alpha_0=1.0;
        ULONG in_new=0;
        vector<s_Halo> final_cat;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
            in_new++;
        final_cat.resize(in_new);
        in_new=0;
        for(ULONG i=0;i<tracer_cat.size();++i)
          if(tracer_cat[i].mass>=mass_bin_min[im] && tracer_cat[i].mass<mass_bin_max[im])
           {
            final_cat[in_new].mass=tracer_cat[i].mass;
            final_cat[in_new].coord1=tracer_cat[i].coord1;
            final_cat[in_new].coord2=tracer_cat[i].coord2;
            final_cat[in_new].coord3=tracer_cat[i].coord3;
            final_cat[in_new].vel1=tracer_cat[i].vel1;
            final_cat[in_new].vel2=tracer_cat[i].vel2;
            final_cat[in_new].vel3=tracer_cat[i].vel3;
            in_new++;
          }

#ifdef _FULL_VERBOSE_
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_min[im]);
        So.message_screen("Minimum value of halo mass selected = ",mass_bin_max[im]);
        So.message_screen("Number of tracers selected = ",in_new);
#endif
        this->N_galaxy=in_new;
        real_prec mean_density=static_cast<real_prec>(in_new)/pow(this->params._Lbox(),3);
        s_data_structure s_data_struct_g;
        s_data_struct_g.properties=final_cat;
        s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
        s_data_struct_g.mean_density=mean_density;
        s_data_struct_g.catalog="data";
        final_cat.clear();final_cat.shrink_to_fit();

        c_Ff.set_n_gal(in_new);

        s_p_box.npixels=c_Ff.npixels;
        s_p_box.nside=c_Ff.nside;
        s_p_box.file_dndz=file_dndz;
        c_Ff.resize_fftw_vectors();
#ifdef _FULL_VERBOSE_
        c_Ff.write_fftw_parameters();
        So.message_screen("Interpolating galaxy density field on a grid");
#endif

    if(space_p=="real")
        c_Ff.get_interpolated_density_field_real_space(&s_data_struct_g);
    else if (space_p=="redshift")
        c_Ff.get_interpolated_density_field(&s_data_struct_g);

        real_prec vol=pow(this->params._Lbox(),3);
        c_Ff.raw_sampling(vol);
        c_Ff.get_parameters_estimator(true);
        c_Ff.get_fluctuation();

      // *****************************************************************************************
        // *****************************************************************************************
        kvector_data.clear();
        kvector_data.shrink_to_fit();
        kvector_window.clear();
        kvector_window.shrink_to_fit();
        if(this->params._type_of_binning()=="linear")
        {
          for(int i=0;i<this->params._d_Nnp_data();i++)
            kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
          for(int i=0;i<this->params._d_Nnp_window();i++)
            kvector_window.push_back(this->params._d_kmin()+this->params._d_DeltaK_window()*(i+0.5));
        }
        else  if(this->params._type_of_binning()=="log")
        {
          for(int i=0;i<kvector_data.size();i++)
            kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
          for(int i=0;i<kvector_window.size();i++)
            kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
        }
        for(int i=0;i<this->params._d_Nnp_data();i++)
          kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
        for(int i=0;i<params._N_mu_bins();i++)
          muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

        // *****************************************************************************
        // Resize arrays for P(k), and 2d P(k). Compute and write to file

        this->pk0.clear();
        this->pk0.shrink_to_fit();
        this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
        this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
        this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
        this->pk_w.clear();
        this->pk_w.shrink_to_fit();
        this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

        this->modes_g.clear();
        this->modes_g.shrink_to_fit();
        this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

        this->pkk.resize(this->params._d_Nnp_data());
        this->pmk.resize(params._N_mu_bins());
#ifdef _WRITE_2DPOWER_
        for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
        for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
#endif
       c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
       So.DONE();
#ifndef _WRITE_MULTIPOLES_
        this->write_power_and_modes();
#else
        this->write_power_spectrum(false); // argument asks to write sigma or not
#endif

  }


}


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
    void PowerSpectrumF::compute_marked_power_spectrum_grid(const vector<real_prec> &data_in,const vector<real_prec> &data_in_MW)
    {


#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif

      FftwFunctions c_Ff(this->params);
      s_parameters_box s_p_box;
      c_Ff.resize_fftw_vectors();

      real_prec ngal_new=get_nobjects(data_in);

      real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
      for(ULONG i=0;i<this->params._NGRID();++i)
	c_Ff.data_g[i]=(static_cast<real_prec>(data_in_MW[i])-static_cast<real_prec>(data_in[i]))/static_cast<real_prec>(nmean);

     this->params.set_ngal_delta(ngal_new);
      c_Ff.set_n_gal(ngal_new);

      real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
      c_Ff.set_normal_power(pow(factor,-2));
      c_Ff.shot_noise=(this->var_prop-1.0)*static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

      kvector_data.resize(this->params._d_Nnp_data(), 0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
      for(int i=0;i<this->params._d_Nnp_data();i++)
        	kvector_data[i]=this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5);

      this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
      this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

      c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->modes_g);
    }


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
    void PowerSpectrumF::compute_power_spectrum_grid()
    {

#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif

      int ir=1;
      FftwFunctions c_Ff(this->params);
      vector<real_prec> data_in(this->params._NGRID(),0);
      So.message_screen("Reading input file on a mesh, with precision set by PrecType_Y directive");
      this->c_Fm.read_array_t<PrecType_Y>(this->params._delta_grid_file(), data_in);
      s_parameters_box s_p_box;
      c_Ff.resize_fftw_vectors();
#ifdef _FULL_VERBOSE_
      c_Ff.write_fftw_parameters();
#endif
#ifdef _NCUTS_POWER_
      string ofile=this->file_power;
      for(int Ni=0;Ni<N_MAX_OCCUPATION;Ni+=2)
      	{
#endif

#ifdef _NCUTS_POWER_
	  if(this->params._input_type()=="density_grid")
	    for(ULONG i=0;i<this->params._NGRID();++i)
	      if(data_in[i]<Ni)
		data_in[i]=0;
	      else
		if(this->params._input_type()=="dela_grid")
		  for(ULONG i=0;i<this->params._NGRID();++i)
		    if(data_in[i]<Ni)
		      data_in[i]=-1;
#endif




	  real_prec ngal_new=get_nobjects(data_in);

	  if(this->params._input_type()=="density_grid")
#ifdef _FULL_VERBOSE_
	    So.message_screen("Number of objects =",ngal_new);
#endif




	  if(this->params._input_type()=="density_grid")
	    {    
	      real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	      for(ULONG i=0;i<this->params._NGRID();++i)
      		c_Ff.data_g[i]=(static_cast<real_prec>(data_in[i])/static_cast<real_prec>(nmean))-1.;
	    }
	  else
	    {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID();++i)
    	 	c_Ff.data_g[i]=data_in[i];
	    }


	 this->params.set_ngal_delta(ngal_new);
	  c_Ff.set_n_gal(ngal_new);

	  real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(c_Ff.data_g.size());
	  c_Ff.set_normal_power(pow(factor,-2));

	  c_Ff.shot_noise=0;
	  if(true==this->params._SN_correction())
	    c_Ff.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
#ifdef _FULL_VERBOSE_
	  So.message_screen("Shot Noise =",c_Ff.shot_noise);
	  So.message_screen("Normalization =",c_Ff._normal_power());
#endif

	  this->kvector_data.resize(this->params._d_Nnp_data(), 0);

	  if("linear" == this->params._type_of_binning())
	    {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	      for(int i=0;i<this->params._d_Nnp_data();i++)
		      this->kvector_data[i]=this->params._d_kmin()+ this->params._d_DeltaK_data()*(i+0.5);

	    }
	  else if("log"==this->params._type_of_binning())
	    {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
	      for(int i=0;i<this->params._d_Nnp_data();i++)
      		this->kvector_data[i]=this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal());
	    }


	  this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
	  this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
	  c_Ff.get_power_spectrum_fkp(&s_p_box, this->pk0,this->modes_g);

#ifdef _NCUTS_POWER_
	  this->file_power=ofile+"_Ncuts"+to_string(Ni);
#endif


	  write_power_and_modes();

#ifdef _NCUTS_POWER_
	}
#endif

    }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
